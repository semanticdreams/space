{"id": "470", "type": "class", "data": "{\"code_str\": \"from OpenGL.GL import *\\nfrom OpenGL.GL.shaders import compileProgram, compileShader\\n\\n\\nclass SubWorld:\\n    vertex_shader_source = \\\"\\\"\\\"\\n    #version 330 core\\n    layout(location = 0) in vec3 position;\\n    layout(location = 1) in vec2 texCoords;\\n\\n    uniform mat4 projection;\\n    uniform mat4 view;\\n\\n    out vec2 TexCoords;\\n\\n    void main()\\n    {\\n        TexCoords = texCoords;\\n        gl_Position = projection * view * vec4(position, 1.0);\\n    }\\n    \\\"\\\"\\\"\\n\\n    fragment_shader_source = \\\"\\\"\\\"\\n    #version 330 core\\n    out vec4 FragColor;\\n    in vec2 TexCoords;\\n\\n    uniform sampler2D screenTexture;\\n\\n    void main()\\n    {\\n        FragColor = texture(screenTexture, TexCoords);\\n    }\\n    \\\"\\\"\\\"\\n    def __init__(self, view):\\n        self.view = view\\n\\n        self.shader = compileProgram(\\n            compileShader(self.vertex_shader_source, GL_VERTEX_SHADER),\\n            compileShader(self.fragment_shader_source, GL_FRAGMENT_SHADER)\\n        )\\n\\n        self.width, self.height = 300, 200\\n\\n        self.fbo, self.screen_texture = self.create_framebuffer(self.width, self.height)\\n\\n        self.update_quad()\\n\\n        self.camera = z.Camera([0, 0, 0], [1, 0, 0, 0])\\n        self.projection = z.Projection()\\n        self.projection.viewport_changed([0, 0, self.width, self.height])\\n\\n        self.text_renderer = z.TextRenderer()\\n        self.text_vector = z.Vector()\\n\\n        self.triangle_renderer = z.TriangleRenderer()\\n        self.triangle_vector = z.Vector()\\n\\n    def update_quad(self):\\n        self.quad_vao = self.create_quad()\\n\\n    def prerender(self):\\n        glBindFramebuffer(GL_FRAMEBUFFER, self.fbo)\\n        glEnable(GL_DEPTH_TEST)\\n        glDepthFunc(GL_LESS)\\n        glClearColor(1.0, 0.0, 0.0, 1.0)\\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\\n\\n        self.triangle_renderer.render(\\n            self.camera.get_view_matrix(),\\n            self.projection.value,\\n            self.triangle_vector.array,\\n            self.camera.position\\n        )\\n        self.text_renderer.render(\\n            self.camera.get_view_matrix(),\\n            self.projection.value,\\n            self.text_vector.array,\\n            world.themes.theme.font\\n        )\\n\\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\\n\\n    def render(self, view, projection):\\n        glUseProgram(self.shader)\\n        glBindVertexArray(self.quad_vao)\\n        glActiveTexture(GL_TEXTURE0)\\n        glBindTexture(GL_TEXTURE_2D, self.screen_texture)\\n        glUniform1i(glGetUniformLocation(self.shader, b\\\"screenTexture\\\"), 0)\\n        glUniform2f(glGetUniformLocation(self.shader, b\\\"resolution\\\"), float(self.width), float(self.height))\\n        glUniformMatrix4fv(\\n            glGetUniformLocation(self.shader, b'projection'), 1, GL_FALSE, projection)\\n        glUniformMatrix4fv(\\n            glGetUniformLocation(self.shader, b'view'), 1, GL_FALSE, view)\\n        glDrawArrays(GL_TRIANGLES, 0, 6)\\n\\n    def drop(self):\\n        glDeleteFramebuffers(1, self.fbo)\\n        glDeleteTextures(self.screen_texture)\\n        glDeleteVertexArrays(self.quad_vao)\\n        glDeleteProgram(self.shader)\\n\\n    def create_framebuffer(self, width, height):\\n        # Create Framebuffer\\n        fbo = glGenFramebuffers(1)\\n        glBindFramebuffer(GL_FRAMEBUFFER, fbo)\\n\\n        # Create Texture Attachment\\n        tex = glGenTextures(1)\\n        glBindTexture(GL_TEXTURE_2D, tex)\\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, None)\\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\\n\\n        # Attach Texture to Framebuffer\\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0)\\n\\n        # Create Renderbuffer Object for Depth & Stencil\\n        rbo = glGenRenderbuffers(1)\\n        glBindRenderbuffer(GL_RENDERBUFFER, rbo)\\n        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height)\\n        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo)\\n\\n        if glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFER_COMPLETE:\\n            print(\\\"Framebuffer is not complete!\\\")\\n\\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\\n        return fbo, tex\\n\\n    def create_quad(self):\\n        layout = self.view.layout\\n\\n        quad_vertices = v = np.array([\\n            # positions   # texCoords\\n            0.0,  1.0, 0,  0.0, 1.0,\\n            0.0, 0.0, 0,  0.0, 0.0,\\n            1.0, 0.0, 0,  1.0, 0.0,\\n            0.0,  1.0,0,   0.0, 1.0,\\n            1.0, 0.0,  0, 1.0, 0.0,\\n            1.0,  1.0, 0,  1.0, 1.0\\n        ], dtype=np.float32)\\n        rotation_matrix = transformations.quaternion_matrix(\\n            layout.rotation)[:-1, :-1]\\n        size = np.array((layout.size[0], layout.size[1], 0))\\n        for i in range(0, v.size, 5):\\n            b = quad_vertices[i:i+3]\\n            v[i:i+3] = np.matmul(rotation_matrix, (size * b)) \\\\\\n                    + layout.position\\n\\n        vao = glGenVertexArrays(1)\\n        vbo = glGenBuffers(1)\\n        glBindVertexArray(vao)\\n        glBindBuffer(GL_ARRAY_BUFFER, vbo)\\n        glBufferData(GL_ARRAY_BUFFER, quad_vertices.nbytes, quad_vertices, GL_STREAM_DRAW)\\n        glEnableVertexAttribArray(0)\\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * quad_vertices.itemsize, ctypes.c_void_p(0))\\n        glEnableVertexAttribArray(1)\\n        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * quad_vertices.itemsize, ctypes.c_void_p(12))\\n        glBindBuffer(GL_ARRAY_BUFFER, 0)\\n        glBindVertexArray(0)\\n        return vao\\n\", \"name\": \"SubWorld\"}", "created_at": null, "updated_at": 1756754129.7231936}