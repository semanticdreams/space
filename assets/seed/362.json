{"id": "362", "type": "class", "data": "{\"code_str\": \"default_key_mapping_sdl2 = {\\n    'move_left': 97,\\n    'move_right': 101,\\n    'move_forward': 44,\\n    'move_backward': 111,\\n    'look_up': 1073741906,\\n    'look_down': 1073741905,\\n    'look_right': 1073741904,\\n    'look_left': 1073741903,\\n    'speed': 32\\n}\\n\\n\\nclass FirstPersonControls:\\n    def __init__(self, camera=None, window=None,\\n                 movement_speed=10, look_speed=1,\\n                 key_mapping=None):\\n        self.camera = camera\\n        self.window = window\\n        self.movement_speed = movement_speed\\n        self.look_speed = look_speed\\n        self.mouse_look_speed = 0.001\\n        self.mouse_move_speed = 0.2\\n\\n        self.speed_multiplier = 1.0\\n\\n        self.scroll_speed = np.array((0, 0), float)\\n        self.max_scroll_speed = 5.0\\n        self.scroll_acceleration = 2.5\\n        self.scroll_deceleration = 0.99\\n\\n        self.drag_look_start = None\\n        self.drag_move_start = None\\n\\n        self.keys = world.window.keys#set()\\n\\n        self.key_mapping = {\\n            **default_key_mapping_sdl2,\\n            **(key_mapping or {})\\n        }\\n\\n        world.states.create_state(name='fpc', on_enter=self.on_enter, on_leave=self.on_leave)\\n\\n    def on_enter(self):\\n        world.window.keyboard.connect(self.on_keyboard)\\n        world.window.scrolled.connect(self.on_scrolled)\\n        world.window.mouse_button.connect(self.on_mouse_button)\\n        world.window.mouse_motion.connect(self.on_mouse_motion)\\n        if world.gamepads.primary:\\n            world.gamepads.primary.button_down.connect(self.on_controller_button_down)\\n        world.updated.connect(self.on_update)\\n\\n    def on_leave(self):\\n        world.window.keyboard.disconnect(self.on_keyboard)\\n        world.window.scrolled.disconnect(self.on_scrolled)\\n        world.window.mouse_button.disconnect(self.on_mouse_button)\\n        world.window.mouse_motion.disconnect(self.on_mouse_motion)\\n        if world.gamepads.primary:\\n            world.gamepads.primary.button_down.disconnect(\\n                self.on_controller_button_down)\\n        world.updated.disconnect(self.on_update)\\n\\n    def on_controller_button_down(self, button, state, timestamp):\\n        if button == 20:\\n            world.states.transit_back()\\n\\n    def on_keyboard(self, key, scancode, action, mods):\\n        if action == 1 and key == sdl2.SDLK_ESCAPE:\\n            world.states.transit_back()\\n#        else:\\n#            if action == 1:\\n#                self.keys.add(key)\\n#            elif action == 0:\\n#                self.keys.discard(key)\\n\\n    def reset_scroll(self):\\n        self.scroll_speed = np.array((0, 0), float)\\n\\n    def on_scrolled(self, x, y):\\n        self.scroll_speed += np.array([x, y]) * self.scroll_acceleration * max(1000, abs(self.camera.position[2])) * 0.001\\n\\n    def on_mouse_button(self, button, action, mods):\\n        if button == sdl2.SDL_BUTTON_LEFT:\\n            if action == 1:\\n                self.drag_look_start = self.window.mouse_pos\\n            else:\\n                self.drag_look_start = None\\n        elif button == sdl2.SDL_BUTTON_RIGHT:\\n            if action == 1:\\n                self.drag_move_start = self.window.mouse_pos\\n            else:\\n                self.drag_move_start = None\\n\\n    def on_mouse_motion(self, x, y):\\n        if self.drag_look_start is not None:\\n            dx = x - self.drag_look_start[0]\\n            dy = y - self.drag_look_start[1]\\n            self.drag_look_start = x, y\\n            self.camera.yaw(dx * self.mouse_look_speed)\\n            self.camera.pitch(dy * self.mouse_look_speed)\\n        if self.drag_move_start is not None:\\n            dx = x - self.drag_move_start[0]\\n            dy = y - self.drag_move_start[1]\\n            self.drag_move_start = x, y\\n            speed = self.mouse_move_speed * abs(self.camera.position[2]) * 0.006\\n            self.camera.right(-dx * speed)\\n            self.camera.up(dy * speed)\\n\\n    def drag_active(self):\\n        return self.drag_look_start is not None or self.drag_move_start is not None\\n\\n    def drop(self):\\n        pass\\n\\n    def scroll_update(self, delta):\\n        if np.any(self.scroll_speed):\\n            ray = world.screen_pos_ray(self.window.mouse_pos)\\n            zoom_factor = self.scroll_speed * np.abs(self.scroll_speed)**1.4 \\\\\\n                    * self.movement_speed * self.speed_multiplier * 0.09# * delta\\n            self.camera.right(zoom_factor[0])\\n            if sdl2.SDLK_LCTRL not in self.keys:\\n                if zoom_factor[1] > 0:\\n                    self.camera.set_position(self.camera.position + ray.direction * zoom_factor[1])\\n                else:\\n                    self.camera.forward(zoom_factor[1])\\n            else:\\n                self.camera.up(zoom_factor[1])\\n\\n            self.scroll_speed *= np.power(self.scroll_deceleration, delta)\\n            if np.linalg.norm(self.scroll_speed) < 0.01:\\n                self.scroll_speed = np.array([0.0, 0.0])\\n            self.scroll_speed = np.clip(self.scroll_speed, -self.max_scroll_speed, self.max_scroll_speed)\\n\\n\\n    def on_update(self, delta):\\n        actions = set(k for k, v in self.key_mapping.items() if v in self.keys)\\n\\n        if 'speed' in actions:\\n            self.speed_multiplier = self.speed_multiplier + delta * 20\\n            self.look_speed_multiplier = 2\\n        else:\\n            self.speed_multiplier = max(1, self.speed_multiplier - delta * 100)\\n            self.look_speed_multiplier = 1\\n\\n        self.scroll_update(delta)\\n\\n        if 'move_left' in actions:\\n            self.camera.right(-delta * self.movement_speed * self.speed_multiplier)\\n        if 'move_right' in actions:\\n            self.camera.right(delta * self.movement_speed * self.speed_multiplier)\\n        if 'move_forward' in actions:\\n            self.camera.forward(delta * self.movement_speed * self.speed_multiplier)\\n        if 'move_backward' in actions:\\n            self.camera.forward(-delta * self.movement_speed * self.speed_multiplier)\\n        if 'move_up' in actions:\\n            self.camera.up(delta * self.movement_speed * self.speed_multiplier)\\n        if 'move_down' in actions:\\n            self.camera.up(-delta * self.movement_speed * self.speed_multiplier)\\n        if 'look_up' in actions:\\n            self.camera.pitch(delta * self.look_speed * self.look_speed_multiplier)\\n        if 'look_down' in actions:\\n            self.camera.pitch(-delta * self.look_speed * self.look_speed_multiplier)\\n        if 'look_right' in actions:\\n            self.camera.yaw(delta * self.look_speed * self.look_speed_multiplier)\\n        if 'look_left' in actions:\\n            self.camera.yaw(-delta * self.look_speed * self.look_speed_multiplier)\\n        if 'roll_left' in actions:\\n            self.camera.roll(delta * self.look_speed * self.look_speed_multiplier)\\n        if 'roll_right' in actions:\\n            self.camera.roll(-delta * self.look_speed * self.look_speed_multiplier)\\n\\n        if not world.gamepads.primary:\\n            return\\n\\n        axes = world.gamepads.primary.get_axes()\\n\\n        threshold = 0.1\\n        axes[(axes > -threshold) & (axes < threshold)] = 0.0\\n\\n        # triggger buttons\\n        trigger_move_speed = 0.8\\n        self.camera.forward(delta * trigger_move_speed * (axes[5] + 1) / 2)\\n        self.camera.forward(delta * trigger_move_speed * -(axes[4] + 1) / 2)\\n\\n        look_speed = 0.003\\n        self.camera.yaw(delta * look_speed * -axes[2])\\n        self.camera.pitch(delta * look_speed * -axes[3])\\n\\n        move_speed = 0.4\\n        self.camera.right(delta * move_speed * axes[0])\\n        self.camera.forward(delta * move_speed * -axes[1])\\n\", \"name\": \"FirstPersonControls\"}", "created_at": null, "updated_at": 1756754129.7286918}