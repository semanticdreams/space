{"id": "444", "type": "class", "data": "{\"code_str\": \"class InputText:\\n    def __init__(self, input, style=None, hud=False, syntax_coloring=False):\\n        self.dropped = False\\n        self.input = input\\n        self.style = style\\n        self.hud = hud\\n        self.syntax_coloring = syntax_coloring\\n\\n        self.caret_rectangle = z.RRectangle(\\n            hidden=True,\\n            color=world.themes.theme.input_caret_color)\\n\\n        if self.hud:\\n            self.vector = world.renderers.get_hud_text_vector(self.style.font)\\n        else:\\n            self.vector = world.renderers.get_scene_text_vector(self.style.font)\\n\\n        self.handle = None\\n\\n        self.layout = z.Layout(measurer=self.measurer, layouter=self.layouter,\\n                               name='input-text')\\n\\n    def set_hud(self, hud):\\n        if hud != self.hud:\\n            if self.handle:\\n                self.vector.delete(self.handle)\\n                self.handle = None\\n            if hud:\\n                self.vector = world.renderers.get_hud_text_vector(self.style.font)\\n            else:\\n                self.vector = world.renderers.get_scene_text_vector(self.style.font)\\n            self.hud = hud\\n            self.update_visible_text()\\n\\n    def measurer(self):\\n        assert not self.dropped\\n        font = self.style.font\\n        self.layout.measure = np.array((0, 0, 0), float)\\n        self.line_gap = 0.5\\n        self.line_height = (font.meta['metrics']['ascender'] - font.meta['metrics']['descender']) * self.style.scale\\n        self.layout.measure[1] = self.line_height * len(self.visible_lines) \\\\\\n                + self.line_gap * (len(self.visible_lines) - 1)\\n        self.layout.measure[0] = font.advance * self.style.scale * self.input.chars_per_line\\n        #max_x_size = 0.0\\n        #for line in self.visible_lines:\\n        #    x_size = 0.0\\n        #    for char in line:\\n        #        codepoint = ord(char)\\n        #        g = font.glyph_map.get(codepoint, font.glyph_map.get(65533))\\n        #        advance = g['advance'] * self.style.scale\\n        #        x_size += advance\\n        #    max_x_size = max(max_x_size, x_size)\\n        #self.layout.measure[0] = max_x_size\\n\\n    def update_caret_rectangle(self):\\n        self.caret_rectangle.set_size((\\n            0.2 if self.input.inserting else \\\\\\n            self.style.font.advance * self.style.scale,\\n            (self.style.font.meta['metrics']['ascender'] \\\\\\n             - self.style.font.meta['metrics']['descender']) * self.style.scale,\\n        ))\\n        self.caret_rectangle.set_rotation(self.layout.rotation)\\n        self.caret_rectangle.set_depth_offset_index(self.layout.depth_offset_index + 1)\\n\\n        p = self.layout.position.copy()\\n        location = self.input.caret_location.copy()\\n        location[0] -= self.input.scroll_offset[0]\\n        location[1] -= self.input.scroll_offset[1]\\n\\n        p[0] += 1.0 * location[0]\\n        p[1] += self.layout.size[1] - self.line_height\\n\\n        assert self.style.font.monospace == True\\n        p[1] -= (self.line_height + self.line_gap) * location[1]\\n\\n        if self.input.inserting:\\n            p[0] -= self.caret_rectangle.size[0] / 2\\n        #p[1] += self.style.font.meta['metrics']['descender'] * self.style.scale\\n        #p[2] += 0.02\\n        self.caret_rectangle.set_position(p)\\n\\n        self.caret_rectangle.update()\\n\\n    def update_color_map(self):\\n        from pygments import lex\\n        from pygments.lexers import PythonLexer\\n        from collections import defaultdict\\n        lexer = PythonLexer()\\n        self.token_map = defaultdict(dict)\\n        line, column = 0, 0\\n        for token_type, token_value in lex(self.input.text, lexer):\\n            for char in token_value:\\n                if char == '\\\\n':\\n                    line += 1\\n                    column = 0\\n                else:\\n                    self.token_map[line][column] = \\\\\\n                            world.themes.theme.get_syntax_color_for_token_type(token_type)\\n                    column += 1\\n\\n    def layouter(self):\\n        assert not self.dropped\\n        self.input.update_rectangle() # TODO move\\n        font = self.style.font\\n        # TODO why is layouter even called with size=0,0,0 at first?\\n        should_update_visible_text = False\\n        new_chars_per_line = int(self.layout.size[0] // (font.advance * self.style.scale))\\n        if new_chars_per_line and self.input.chars_per_line != new_chars_per_line:\\n            self.input.set_chars_per_line(new_chars_per_line)\\n            should_update_visible_text = True\\n        new_max_lines = int((self.layout.size[1] + self.line_gap) // (self.line_height + self.line_gap))\\n        if new_max_lines and new_max_lines != self.input.max_lines:\\n            assert new_max_lines > 0\\n            self.input.max_lines = new_max_lines\\n            should_update_visible_text = True\\n        if should_update_visible_text:\\n            self.update_visible_text(update_layout=False)\\n        char_vertices_len = 10 * 6\\n        x_cursor, y_cursor = 0.0, self.layout.size[1] - font.meta['metrics']['ascender'] * self.style.scale\\n        v = self.vector.view(self.handle)\\n        i = 0\\n        for line_idx, line in enumerate(self.visible_lines):\\n            if line:\\n                for char_idx, (char, color) in enumerate(line):\\n                    vv = v[i*char_vertices_len:(i+1)*char_vertices_len]\\n                    i += 1 # TODO later i can ignore space character\\n                    g = font.glyph_map.get(ord(char), font.glyph_map.get(65533))\\n                    advance = g['advance'] * self.style.scale\\n                    plane_bounds = g.get('planeBounds')\\n                    atlas_bounds = g.get('atlasBounds')\\n                    if plane_bounds is None or atlas_bounds is None:\\n                        x_cursor += advance\\n                        continue\\n                    x0 = x_cursor + plane_bounds['left'] * self.style.scale\\n                    y0 = plane_bounds['bottom'] * self.style.scale\\n                    x1 = x_cursor + plane_bounds['right'] * self.style.scale\\n                    y1 = plane_bounds['top'] * self.style.scale\\n                    s0 = atlas_bounds['left'] / font.meta['atlas']['width']\\n                    s1 = atlas_bounds['right'] / font.meta['atlas']['width']\\n                    t1 = 1.0 - (atlas_bounds['top'] / font.meta['atlas']['height'])\\n                    t0 = 1.0 - (atlas_bounds['bottom'] / font.meta['atlas']['height'])\\n\\n                    vv[0:9] = [x0, y0, 0.0, s0, t0, *color]\\n                    vv[10:19] = [x1, y0, 0.0, s1, t0, *color]\\n                    vv[20:29] = [x1, y1, 0.0, s1, t1, *color]\\n                    vv[30:39] = [x0, y0, 0.0, s0, t0, *color]\\n                    vv[40:49] = [x1, y1, 0.0, s1, t1, *color]\\n                    vv[50:59] = [x0, y1, 0.0, s0, t1, *color]\\n\\n                    rotation_matrix = transformations.quaternion_matrix(self.layout.rotation)[:-1, :-1]\\n                    for j in range(0, vv.size, 10):\\n                        vv[j:j+3] = np.matmul(rotation_matrix, vv[j:j+3])\\n                    for j in range(0, vv.size, 10):\\n                        vv[j:j+3] += self.layout.position\\n                        vv[j+1] += y_cursor\\n                        vv[j+9] = self.layout.depth_offset_index + 2\\n                    x_cursor += advance\\n            y_cursor -= (self.line_height + self.line_gap)\\n            x_cursor = 0.0\\n        self.update_caret_rectangle()\\n\\n    def update_visible_text(self, update_layout=True):\\n        if self.syntax_coloring:\\n            self.update_color_map()\\n        self.visible_lines = []\\n        self.input.set_num_lines(max(self.input.min_lines,\\n                                   min(self.input.max_lines, len(self.input.lines) + 1)))\\n        for i in range(self.input.scroll_offset[1], min(len(self.input.lines), self.input.scroll_offset[1]+self.input.num_lines)):\\n            line = self.input.lines[i]\\n            if not line:\\n                self.visible_lines.append(None)\\n            elif self.input.multiline and False:#self.input.wrap_lines:\\n                # TODO this can't work, need to expand lines before scroll offset is calculated. essentially this needs to be a step between caret location and scroll offset\\n                for j in range(0, len(line), self.input.chars_per_line):\\n                    visible_line = []\\n                    for k in range(j, min(len(line), j+self.input.chars_per_line)):\\n                        color = self.token_map[i][k] if self.syntax_coloring else self.style.color\\n                        visible_line.append((line[k], color))\\n                    self.visible_lines.append(visible_line)\\n            else:\\n                visible_line = []\\n                for k in range(self.input.scroll_offset[0], min(len(line), self.input.scroll_offset[0]+self.input.chars_per_line)):\\n                    color = self.token_map[i][k] if self.syntax_coloring and k in self.token_map[i] else self.style.color\\n                    visible_line.append((line[k], color))\\n                self.visible_lines.append(visible_line)\\n\\n        self.visible_lines.extend([None] * (self.input.num_lines - len(self.visible_lines)))\\n        if self.handle:\\n            self.vector.delete(self.handle)\\n        chars_count = sum(len(x) if x else 0 for x in self.visible_lines)\\n        self.handle = self.vector.allocate(10 * 6 * chars_count)\\n        #self.layout.mark_measure_dirty()\\n        if update_layout:\\n            self.layout.mark_measure_dirty()\\n\\n    def show_caret(self):\\n        self.caret_rectangle.show()\\n        self.caret_rectangle.update()\\n\\n    def hide_caret(self):\\n        self.caret_rectangle.hide()\\n        self.caret_rectangle.update()\\n\\n    def drop(self):\\n        self.layout.drop()\\n        self.caret_rectangle.drop()\\n        if self.handle:\\n            self.vector.delete(self.handle)\\n        self.dropped = True\\n\", \"name\": \"InputText\"}", "created_at": null, "updated_at": 1756754129.7315855}