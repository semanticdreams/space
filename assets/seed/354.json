{"id": "354", "type": "class", "data": "{\"code_str\": \"from OpenGL.GL import *\\nfrom OpenGL.GL.shaders import compileProgram, compileShader\\n\\nvertex_shader_source = \\\"\\\"\\\"\\n#version 330 core\\nout vec2 v_texCoord;\\n\\nvoid main(void)\\n{\\n\\tvec4 vertices[4] = vec4[4](vec4(-1.0, -1.0, 0.0, 1.0), vec4(1.0, -1.0, 0.0, 1.0), vec4(-1.0, 1.0, 0.0, 1.0), vec4(1.0, 1.0, 0.0, 1.0));\\n\\tvec2 texCoord[4] = vec2[4](vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0));\\n\\n\\tv_texCoord = texCoord[gl_VertexID];\\n\\n\\tgl_Position = vertices[gl_VertexID];\\n}\\n\\\"\\\"\\\"\\n\\nfragment_shader_source = \\\"\\\"\\\"\\n#version 330 core\\nout vec4 fragColor;\\nin vec2 v_texCoord;\\n\\nuniform sampler2D u_colorTexture;\\n\\nuniform vec2 u_texelStep;\\nuniform int u_showEdges;\\nuniform int u_fxaaOn;\\n\\nuniform float u_lumaThreshold;\\nuniform float u_mulReduce;\\nuniform float u_minReduce;\\nuniform float u_maxSpan;\\n\\n// see FXAA\\n// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\\n// http://iryoku.com/aacourse/downloads/09-FXAA-3.11-in-15-Slides.pdf\\n// http://horde3d.org/wiki/index.php5?title=Shading_Technique_-_FXAA\\n\\nvoid main(void)\\n{\\n    vec3 rgbM = texture(u_colorTexture, v_texCoord).rgb;\\n\\n\\t// Possibility to toggle FXAA on and off.\\n\\tif (u_fxaaOn == 0)\\n\\t{\\n\\t\\tfragColor = vec4(rgbM, 1.0);\\n\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Sampling neighbour texels. Offsets are adapted to OpenGL texture coordinates.\\n\\tvec3 rgbNW = textureOffset(u_colorTexture, v_texCoord, ivec2(-1, 1)).rgb;\\n    vec3 rgbNE = textureOffset(u_colorTexture, v_texCoord, ivec2(1, 1)).rgb;\\n    vec3 rgbSW = textureOffset(u_colorTexture, v_texCoord, ivec2(-1, -1)).rgb;\\n    vec3 rgbSE = textureOffset(u_colorTexture, v_texCoord, ivec2(1, -1)).rgb;\\n\\n\\t// see http://en.wikipedia.org/wiki/Grayscale\\n\\tconst vec3 toLuma = vec3(0.299, 0.587, 0.114);\\n\\n\\t// Convert from RGB to luma.\\n\\tfloat lumaNW = dot(rgbNW, toLuma);\\n\\tfloat lumaNE = dot(rgbNE, toLuma);\\n\\tfloat lumaSW = dot(rgbSW, toLuma);\\n\\tfloat lumaSE = dot(rgbSE, toLuma);\\n\\tfloat lumaM = dot(rgbM, toLuma);\\n\\n\\t// Gather minimum and maximum luma.\\n\\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\\n\\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\\n\\n\\t// If contrast is lower than a maximum threshold ...\\n\\tif (lumaMax - lumaMin <= lumaMax * u_lumaThreshold)\\n\\t{\\n\\t\\t// ... do no AA and return.\\n\\t\\tfragColor = vec4(rgbM, 1.0);\\n\\n\\t\\treturn;\\n\\t}\\n\\n\\t// Sampling is done along the gradient.\\n\\tvec2 samplingDirection;\\n\\tsamplingDirection.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\\n    samplingDirection.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\\n\\n    // Sampling step distance depends on the luma: The brighter the sampled texels, the smaller the final sampling step direction.\\n    // This results, that brighter areas are less blurred/more sharper than dark areas.\\n    float samplingDirectionReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25 * u_mulReduce, u_minReduce);\\n\\n\\t// Factor for norming the sampling direction plus adding the brightness influence.\\n\\tfloat minSamplingDirectionFactor = 1.0 / (min(abs(samplingDirection.x), abs(samplingDirection.y)) + samplingDirectionReduce);\\n\\n    // Calculate final sampling direction vector by reducing, clamping to a range and finally adapting to the texture size.\\n    samplingDirection = clamp(samplingDirection * minSamplingDirectionFactor, vec2(-u_maxSpan), vec2(u_maxSpan)) * u_texelStep;\\n\\n\\t// Inner samples on the tab.\\n\\tvec3 rgbSampleNeg = texture(u_colorTexture, v_texCoord + samplingDirection * (1.0/3.0 - 0.5)).rgb;\\n\\tvec3 rgbSamplePos = texture(u_colorTexture, v_texCoord + samplingDirection * (2.0/3.0 - 0.5)).rgb;\\n\\n\\tvec3 rgbTwoTab = (rgbSamplePos + rgbSampleNeg) * 0.5;\\n\\n\\t// Outer samples on the tab.\\n\\tvec3 rgbSampleNegOuter = texture(u_colorTexture, v_texCoord + samplingDirection * (0.0/3.0 - 0.5)).rgb;\\n\\tvec3 rgbSamplePosOuter = texture(u_colorTexture, v_texCoord + samplingDirection * (3.0/3.0 - 0.5)).rgb;\\n\\n\\tvec3 rgbFourTab = (rgbSamplePosOuter + rgbSampleNegOuter) * 0.25 + rgbTwoTab * 0.5;\\n\\n\\t// Calculate luma for checking against the minimum and maximum value.\\n\\tfloat lumaFourTab = dot(rgbFourTab, toLuma);\\n\\n\\t// Are outer samples of the tab beyond the edge ...\\n\\tif (lumaFourTab < lumaMin || lumaFourTab > lumaMax)\\n\\t{\\n\\t\\t// ... yes, so use only two samples.\\n\\t\\tfragColor = vec4(rgbTwoTab, 1.0);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\t// ... no, so use four samples.\\n\\t\\tfragColor = vec4(rgbFourTab, 1.0);\\n\\t}\\n\\n\\t// Show edges for debug purposes.\\n\\tif (u_showEdges != 0)\\n\\t{\\n\\t\\tfragColor.r = 1.0;\\n\\t}\\n}\\n\\\"\\\"\\\"\\n\\nclass Fxaa:\\n    MAX_MUL_REDUCE_RECIPROCAL = 256.0\\n    MAX_MIN_REDUCE_RECIPROCAL = 512.0\\n    MAX_MAX_SPAN = 16.0\\n\\n    def __init__(self):\\n        self.on = 1\\n        self.show_edges = 0\\n        self.luma_threshold = 0.5 # step +0.05\\n        self.mul_reduce_reciprocal = 8.0 # step *2.0\\n        self.min_reduce_reciprocal = 128.0 # step *2.0\\n        self.max_span = 8.0 # step +1.0\\n\\n        self.shader = compileProgram(\\n            compileShader(vertex_shader_source, GL_VERTEX_SHADER),\\n            compileShader(fragment_shader_source, GL_FRAGMENT_SHADER)\\n        )\\n\\n        self.fbo, self.screen_texture = self.create_framebuffer(*world.viewport.value[2:4])\\n\\n        self.vao = glGenVertexArrays(1)\\n        vbo = glGenBuffers(1)\\n        glBindVertexArray(self.vao)\\n        glBindVertexArray(0)\\n\\n    def set_luma_threshold(self, value):\\n        self.luma_threshold = np.clip(value, 0.0, 1.0)\\n\\n    def set_mul_reduce_reciprocal(self, value):\\n        self.mul_reduce_reciprocal = np.clip(value, 1.0, self.MAX_MUL_REDUCE_RECIPROCAL)\\n\\n    def set_min_reduce_reciprocal(self, value):\\n        self.min_reduce_reciprocal = np.clip(value, 1.0, self.MAX_MIN_REDUCE_RECIPROCAL)\\n\\n    def set_max_span(self, value):\\n        self.max_span = np.clip(value, 1.0, self.MAX_MAX_SPAN)\\n\\n    def viewport_changed(self, viewport):\\n        glDeleteFramebuffers(1, self.fbo)\\n        glDeleteRenderbuffers(1, self.rbo)\\n        glDeleteTextures(self.screen_texture)\\n        self.fbo, self.screen_texture = self.create_framebuffer(viewport[2], viewport[3])\\n\\n    def render(self):\\n        glUseProgram(self.shader)\\n        glBindVertexArray(self.vao)\\n        glActiveTexture(GL_TEXTURE0)\\n        glBindTexture(GL_TEXTURE_2D, self.screen_texture)\\n        glUniform1i(glGetUniformLocation(self.shader, b\\\"u_colorTexture\\\"), 0)\\n\\n        glUniform2f(glGetUniformLocation(self.shader, b'u_texelStep'),\\n                    1.0 / float(world.viewport.value[2]), 1.0 / float(world.viewport.value[3]))\\n        glUniform1i(glGetUniformLocation(self.shader, b'u_showEdges'), self.show_edges)\\n        glUniform1i(glGetUniformLocation(self.shader, b'u_fxaaOn'), self.on)\\n        glUniform1f(glGetUniformLocation(self.shader, b'u_lumaThreshold'), self.luma_threshold)\\n        glUniform1f(glGetUniformLocation(self.shader, b'u_mulReduce'), 1.0 / self.mul_reduce_reciprocal)\\n        glUniform1f(glGetUniformLocation(self.shader, b'u_minReduce'), 1.0 / self.min_reduce_reciprocal)\\n        glUniform1f(glGetUniformLocation(self.shader, b'u_maxSpan'), self.max_span)\\n\\n        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)\\n\\n    def drop(self):\\n        glDeleteFramebuffers(1, self.fbo)\\n        glDeleteRenderbuffers(1, self.rbo)\\n        glDeleteTextures(self.screen_texture)\\n        glDeleteVertexArrays(self.vao)\\n        glDeleteProgram(self.shader)\\n\\n    def create_framebuffer(self, width, height):\\n        # Create Framebuffer\\n        fbo = glGenFramebuffers(1)\\n        glBindFramebuffer(GL_FRAMEBUFFER, fbo)\\n\\n        # Create Texture Attachment\\n        tex = glGenTextures(1)\\n        glBindTexture(GL_TEXTURE_2D, tex)\\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, None)\\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\\n\\n        # Attach Texture to Framebuffer\\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0)\\n\\n        # Create Renderbuffer Object for Depth & Stencil\\n        self.rbo = glGenRenderbuffers(1)\\n        glBindRenderbuffer(GL_RENDERBUFFER, self.rbo)\\n\\n        #glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height)\\n        #glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, self.rbo)\\n\\n        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, width, height)\\n        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, self.rbo)\\n\\n        if glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE:\\n            print(\\\"Framebuffer is not complete!\\\")\\n\\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\\n        return fbo, tex\\n\", \"name\": \"Fxaa\"}", "created_at": null, "updated_at": 1754239007.4993308}