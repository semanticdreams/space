{"id": "50", "type": "code", "data": "{\"code_str\": \"import av\\nimport sdl2\\nimport sdl2.ext\\nfrom OpenGL.GL import *\\nfrom OpenGL.GLU import *\\nimport numpy as np\\nimport ctypes\\nimport time\\n\\ndef init_sdl(width, height):\\n    sdl2.SDL_Init(sdl2.SDL_INIT_VIDEO)\\n    window = sdl2.SDL_CreateWindow(b\\\"Video Texture 3D\\\",\\n                                   sdl2.SDL_WINDOWPOS_CENTERED,\\n                                   sdl2.SDL_WINDOWPOS_CENTERED,\\n                                   800, 600,\\n                                   sdl2.SDL_WINDOW_OPENGL)\\n    sdl2.SDL_GL_CreateContext(window)\\n\\n    glEnable(GL_TEXTURE_2D)\\n    glEnable(GL_DEPTH_TEST)\\n    glClearColor(0.1, 0.1, 0.1, 1.0)\\n\\n    glMatrixMode(GL_PROJECTION)\\n    glLoadIdentity()\\n    gluPerspective(45, 800 / 600, 0.1, 100.0)\\n\\n    glMatrixMode(GL_MODELVIEW)\\n    glLoadIdentity()\\n\\n    return window\\n\\ndef create_texture(width, height):\\n    texture = glGenTextures(1)\\n    glBindTexture(GL_TEXTURE_2D, texture)\\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\\n\\n    # Allocate texture memory\\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0,\\n                 GL_RGB, GL_UNSIGNED_BYTE, None)\\n    return texture\\n\\ndef update_texture(texture, width, height, frame_data):\\n    glBindTexture(GL_TEXTURE_2D, texture)\\n    glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height,\\n                    GL_RGB, GL_UNSIGNED_BYTE, frame_data)\\n\\ndef draw_textured_quad():\\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\\n    glLoadIdentity()\\n    glTranslatef(0.0, 0.0, -3.0)\\n    glRotatef(25, 1, 0, 0)\\n\\n    glBegin(GL_QUADS)\\n    glTexCoord2f(0, 1); glVertex3f(-1, -1, 0)\\n    glTexCoord2f(1, 1); glVertex3f(1, -1, 0)\\n    glTexCoord2f(1, 0); glVertex3f(1, 1, 0)\\n    glTexCoord2f(0, 0); glVertex3f(-1, 1, 0)\\n    glEnd()\\n\\ndef main():\\n    container = av.open(VIDEO_PATH)\\n    video_stream = container.streams.video[0]\\n    video_stream.thread_type = 'AUTO'\\n\\n    width = video_stream.codec_context.width\\n    height = video_stream.codec_context.height\\n\\n    window = init_sdl(width, height)\\n    texture = create_texture(width, height)\\n\\n    event = sdl2.SDL_Event()\\n    start_time = time.time()\\n\\n    for frame in container.decode(video=0):\\n        while sdl2.SDL_PollEvent(ctypes.byref(event)) != 0:\\n            if event.type == sdl2.SDL_QUIT:\\n                sdl2.SDL_Quit()\\n                return\\n\\n        # Convert frame to RGB and get numpy array\\n        rgb_frame = frame.to_rgb()\\n        frame_array = rgb_frame.to_ndarray()\\n        frame_array = np.flip(frame_array, axis=0)  # OpenGL expects bottom-up\\n        frame_data = frame_array.tobytes()\\n\\n        update_texture(texture, width, height, frame_data)\\n        draw_textured_quad()\\n        sdl2.SDL_GL_SwapWindow(window)\\n\\n        # Frame timing using pts\\n        if frame.pts is not None and frame.time_base is not None:\\n            target_time = float(frame.pts * frame.time_base)\\n            current_time = time.time() - start_time\\n            delay = target_time - current_time\\n            if delay > 0:\\n                time.sleep(delay)\\n\\n    sdl2.SDL_DestroyWindow(window)\\n    sdl2.SDL_Quit()\\n\\n\", \"name\": \"video playback using av\", \"kernel\": 0, \"lang\": \"py\", \"summary\": null, \"project_id\": 1, \"autolaunch\": 0}", "created_at": null, "updated_at": null}