{"id": "404", "type": "class", "data": "{\"code_str\": \"class FocusSystem:\\n    def __init__(self):\\n        self.root = z.FocusNode()\\n        self.current = None\\n        world.focus = self\\n\\n    def dump(self):\\n        self.root.dump()\\n\\n    # for legacy compat\\n    def add_child(self, obj, on_changed=None, on_subtree_changed=None):\\n        return self.root.add_child(obj, on_changed, on_subtree_changed=on_subtree_changed)\\n\\n    def create_node(self, obj=None, on_changed=None, on_subtree_changed=None, parent=None):\\n        parent = parent or self.root\\n        node = z.FocusNode(obj=obj,\\n                         on_changed=on_changed,\\n                         on_subtree_changed=on_subtree_changed,\\n                         parent=parent)\\n        parent.children.append(node)\\n        if parent == self.current:\\n            self.set_focus(node)\\n        if self.current is None:\\n            self.set_focus(node)\\n        return node\\n\\n    def drop_node(self, node):\\n        assert not node.children, node.children\\n        node.parent.children.remove(node)\\n        if self.current == node:\\n            self.focus_nearest_root_child(node)\\n        if self.current == node:\\n            self.unfocus()\\n\\n    def unfocus(self):\\n        if self.current:\\n            self.current.on_changed(False)\\n            while self.current:\\n                self.current.on_subtree_changed(False)\\n                self.current = self.current.parent\\n\\n    def set_focus(self, node):\\n        assert node\\n        node = self.find_first_leaf(node)\\n        if self.current != node:\\n            if self.current:\\n                self.current.on_changed(False)\\n            n, node_ancestors = node, []\\n            while n:\\n                node_ancestors.append(n)\\n                n = n.parent\\n            i = len(node_ancestors) - 1\\n            while self.current:\\n                if self.current in node_ancestors:\\n                    i = node_ancestors.index(self.current)\\n                    break\\n                self.current.on_subtree_changed(False)\\n                self.current = self.current.parent\\n            for n in reversed(node_ancestors[:i]):\\n                n.on_subtree_changed(True)\\n            node.on_changed(True)\\n            self.current = node\\n\\n    def find_first_leaf(self, node):\\n        # Helper method to find the first leaf in the subtree of the given node\\n        while node.children:\\n            node = node.children[0]\\n        return node\\n\\n    def find_next_leaf(self, node):\\n        # Helper method to find the next leaf node in the tree\\n        while node.parent is not None:\\n            # Try to find a following sibling\\n            parent = node.parent\\n            index = parent.children.index(node)\\n            if index + 1 < len(parent.children):\\n                # If a following sibling exists, find its first leaf descendant\\n                return self.find_first_leaf(parent.children[index + 1])\\n            # If no following sibling, move up to the parent\\n            node = parent\\n        # If no next leaf found, return the first leaf of the entire tree\\n        return self.find_first_leaf(self.root)\\n\\n    def find_last_leaf(self, node):\\n        # Helper method to find the last leaf in the subtree of the given node\\n        while node.children:\\n            node = node.children[-1]\\n        return node\\n\\n    def find_previous_leaf(self, node):\\n        # Helper method to find the previous leaf node in the tree\\n        while node.parent is not None:\\n            parent = node.parent\\n            index = parent.children.index(node)\\n            if index > 0:\\n                # If a preceding sibling exists, find its last leaf descendant\\n                return self.find_last_leaf(parent.children[index - 1])\\n            # If no preceding sibling, move up to the parent\\n            node = parent\\n        # If no previous leaf found, return the last leaf of the entire tree\\n        return self.find_last_leaf(self.root)\\n\\n    def focus_previous(self):\\n        if not self.current:\\n            return self.set_focus(self.root)\\n        self.set_focus(self.find_previous_leaf(self.current))\\n\\n    def focus_next(self):\\n        if not self.current:\\n            return self.set_focus(self.root)\\n        self.set_focus(self.find_next_leaf(self.current))\\n\\n    def focus_next_sibling(self, node):\\n        idx = node.parent.children.index(node)\\n        if idx + 1 < len(node.parent.children):\\n            self.set_focus(node.parent.children[idx + 1])\\n\\n    def focus_previous_sibling(self, node):\\n        idx = node.parent.children.index(node)\\n        if idx > 0:\\n            self.set_focus(node.parent.children[idx - 1])\\n\\n    def find_leaves(self):\\n        leaves = []\\n        stack = [self.root]\\n        while stack:\\n            node = stack.pop()\\n            if not node.children:\\n                leaves.append(node)\\n            else:\\n                stack.extend(reversed(node.children))\\n        return leaves\\n\\n    def focus_left(self):\\n        if not self.current:\\n            return self.set_focus(self.root)\\n\\n        nodes = [x for x in self.find_leaves() if x != self.current]\\n\\n        # vectors from left edge of current obj to right edge of each candidate\\n        # centered on y and z axis\\n        # eventually need to align with camera instead\\n        vecs = [(x.obj.layout.position \\\\\\n                 + np.array((x.obj.layout.size[0],\\n                             x.obj.layout.size[1] / 2,\\n                             x.obj.layout.size[2] / 2))) \\\\\\n                - (self.current.obj.layout.position \\\\\\n                   + np.array((0,\\n                               self.current.obj.layout.size[1] / 2,\\n                               self.current.obj.layout.size[2] / 2)))\\n                for x in nodes]\\n\\n        # could just check sign of vecs[i][0] instead of computing angle\\n        candidates = [i for i, x in enumerate(vecs)\\n                      if util.angle_between_vectors([-1, 0, 0], vecs[i]) < 1.57]\\n        if candidates:\\n            idx = sorted(candidates,\\n                         key=lambda i: np.linalg.norm(vecs[i]),\\n                         reverse=False)[0]\\n            self.set_focus(nodes[idx])\\n\\n    def focus_right(self):\\n        if not self.current:\\n            return self.set_focus(self.root)\\n\\n        nodes = [x for x in self.find_leaves() if x != self.current]\\n\\n        vecs = [(x.obj.layout.position \\\\\\n                 + np.array((0,\\n                             x.obj.layout.size[1] / 2,\\n                             x.obj.layout.size[2] / 2))) \\\\\\n                - (self.current.obj.layout.position \\\\\\n                   + np.array((self.current.obj.layout.size[0],\\n                               self.current.obj.layout.size[1] / 2,\\n                               self.current.obj.layout.size[2] / 2)))\\n                for x in nodes]\\n\\n        candidates = [i for i, x in enumerate(vecs)\\n                      if util.angle_between_vectors([1, 0, 0], vecs[i]) < 1.57]\\n        if candidates:\\n            idx = sorted(candidates,\\n                         key=lambda i: np.linalg.norm(vecs[i]),\\n                         reverse=False)[0]\\n            self.set_focus(nodes[idx])\\n\\n    def focus_up(self):\\n        if not self.current:\\n            return self.set_focus(self.root)\\n\\n        nodes = [x for x in self.find_leaves() if x != self.current]\\n\\n        vecs = [(x.obj.layout.position \\\\\\n                 + np.array((x.obj.layout.size[0] / 2,\\n                             0,\\n                             x.obj.layout.size[2] / 2))) \\\\\\n                - (self.current.obj.layout.position \\\\\\n                   + np.array((self.current.obj.layout.size[0] / 2,\\n                               self.current.obj.layout.size[1],\\n                               self.current.obj.layout.size[2] / 2)))\\n                for x in nodes]\\n\\n        candidates = [i for i, x in enumerate(vecs)\\n                      if util.angle_between_vectors([0, 1, 0], vecs[i]) < 1.57]\\n        if candidates:\\n            idx = sorted(candidates,\\n                         key=lambda i: np.linalg.norm(vecs[i]),\\n                         reverse=False)[0]\\n            self.set_focus(nodes[idx])\\n\\n    def focus_down(self):\\n        if not self.current:\\n            return self.set_focus(self.root)\\n\\n        nodes = [x for x in self.find_leaves() if x != self.current]\\n\\n        vecs = [(x.obj.layout.position \\\\\\n                 + np.array((x.obj.layout.size[0] / 2,\\n                             x.obj.layout.size[1],\\n                             x.obj.layout.size[2] / 2))) \\\\\\n                - (self.current.obj.layout.position \\\\\\n                   + np.array((self.current.obj.layout.size[0] / 2,\\n                               0,\\n                               self.current.obj.layout.size[2] / 2)))\\n                for x in nodes]\\n\\n        candidates = [i for i, x in enumerate(vecs)\\n                      if util.angle_between_vectors([0, -1, 0], vecs[i]) < 1.57]\\n        if candidates:\\n            idx = sorted(candidates,\\n                         key=lambda i: np.linalg.norm(vecs[i]),\\n                         reverse=False)[0]\\n            self.set_focus(nodes[idx])\\n\\n    def focus_nearest_root_child(self, node):\\n        candidates = self.root.children\\n        if candidates:\\n            nearest = sorted(candidates,\\n                             key=lambda x: np.linalg.norm(x.obj.layout.position \\\\\\n                                                          - node.obj.layout.position))[0]\\n            self.set_focus(nearest)\\n\\n    def drop(self):\\n        pass\\n\", \"name\": \"FocusSystem\"}", "created_at": null, "updated_at": 1754239007.5033042}