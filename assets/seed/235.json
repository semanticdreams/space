{"id": "235", "type": "class", "data": "{\"code_str\": \"class TextSpan:\\n    def __init__(self, text=None, codepoints=None, style=None, hud=False):\\n        self.hud = hud\\n        self.codepoints = codepoints if text is None else [ord(c) for c in text]\\n        self.style = style or z.TextStyle()\\n        self.layout = z.Layout(measurer=self.measurer, layouter=self.layouter, name='text-span')\\n        if self.hud:\\n            self.vector = world.renderers.get_hud_text_vector(self.style.font)\\n        else:\\n            self.vector = world.renderers.get_scene_text_vector(self.style.font)\\n        self.handle = None\\n\\n        self.glyph_positions = []\\n        self.glyph_advances = []\\n\\n        self.dirty = {'text'}\\n        self.update_text()\\n\\n    def set_hud(self, hud):\\n        if hud != self.hud:\\n            if self.handle:\\n                self.vector.delete(self.handle)\\n                self.handle = None\\n            if hud:\\n                self.vector = world.renderers.get_hud_text_vector(self.style.font)\\n            else:\\n                self.vector = world.renderers.get_scene_text_vector(self.style.font)\\n            self.dirty.add('text')\\n            self.update_text()\\n\\n        self.hud = hud\\n\\n    def set_text(self, text, mark_layout_measure_dirty=True):\\n        self.codepoints = [ord(c) for c in text]\\n        self.dirty.add('text')\\n        self.update_text()\\n        if mark_layout_measure_dirty:\\n            self.layout.mark_measure_dirty()\\n\\n    def update_text(self):\\n        if 'text' in self.dirty:\\n            if self.handle:\\n                self.vector.delete(self.handle)\\n            self.handle = self.vector.allocate(10 * 6 * len(self.codepoints))\\n            self.dirty.remove('text')\\n\\n    def measurer(self):\\n        font = self.style.font\\n        #self.update_text()\\n        self.layout.measure = np.array((0, 0, 0), float)\\n        self.layout.measure[1] = (font.meta['metrics']['ascender'] - font.meta['metrics']['descender']) \\\\\\n                * self.style.scale\\n        for i, c in enumerate(self.codepoints):\\n            g = font.glyph_map.get(c, font.glyph_map.get(65533))\\n            advance = g['advance'] * self.style.scale\\n            self.layout.measure[0] += advance\\n\\n    def layouter(self):\\n        font = self.style.font\\n        char_vertices_len = 10 * 6\\n        x_cursor = 0.0\\n        v = self.vector.view(self.handle)\\n        self.glyph_positions.clear()\\n        self.glyph_advances.clear()\\n        for i, c in enumerate(self.codepoints):\\n            vv = v[i*char_vertices_len:(i+1)*char_vertices_len]\\n            g = font.glyph_map.get(c, font.glyph_map.get(65533))\\n            advance = g['advance'] * self.style.scale\\n            self.glyph_advances.append(advance)\\n            plane_bounds = g.get('planeBounds')\\n            atlas_bounds = g.get('atlasBounds')\\n\\n            # Handle space character separately (no plane or atlas bounds, just advance)\\n            if plane_bounds is None or atlas_bounds is None:\\n                self.glyph_positions.append(self.layout.position + transformations.rotate_vector(self.layout.rotation, np.array([x_cursor, 0, 0], float)))\\n                x_cursor += advance\\n                continue\\n\\n            x0 = x_cursor + plane_bounds['left'] * self.style.scale\\n            y0 = plane_bounds['bottom'] * self.style.scale\\n            x1 = x_cursor + plane_bounds['right'] * self.style.scale\\n            y1 = plane_bounds['top'] * self.style.scale\\n\\n            s0 = atlas_bounds['left'] / font.meta['atlas']['width']\\n            s1 = atlas_bounds['right'] / font.meta['atlas']['width']\\n\\n            t1 = 1.0 - (atlas_bounds['top'] / font.meta['atlas']['height'])\\n            t0 = 1.0 - (atlas_bounds['bottom'] / font.meta['atlas']['height'])\\n\\n            vv[0:9] = [x0, y0, 0.0, s0, t0, *self.style.color]\\n            vv[10:19] = [x1, y0, 0.0, s1, t0, *self.style.color]\\n            vv[20:29] = [x1, y1, 0.0, s1, t1, *self.style.color]\\n            vv[30:39] = [x0, y0, 0.0, s0, t0, *self.style.color]\\n            vv[40:49] = [x1, y1, 0.0, s1, t1, *self.style.color]\\n            vv[50:59] = [x0, y1, 0.0, s0, t1, *self.style.color]\\n\\n            # apply rotation\\n            rotation_matrix = transformations.quaternion_matrix(self.layout.rotation)[:-1, :-1]\\n            for j in range(0, vv.size, 10):\\n                vv[j:j+3] = np.matmul(rotation_matrix, vv[j:j+3])\\n\\n            # apply position\\n            for j in range(0, vv.size, 10):\\n                vv[j:j+3] += self.layout.position\\n                vv[j+9] = self.layout.depth_offset_index\\n\\n            self.glyph_positions.append(np.array(vv[j:j+3]))\\n            #x += self.glyph_sizes[i][0]\\n            x_cursor += advance\\n\\n    def get_char_position(self, i):\\n        return self.glyph_positions[i]\\n\\n    def get_char_size(self, i):\\n        return self.glyph_sizes[i]\\n\\n    def drop(self):\\n        self.vector.delete(self.handle)\\n        self.layout.drop()\\n\", \"name\": \"TextSpan\"}", "created_at": null, "updated_at": 1754736945.4500802}