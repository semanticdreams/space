{"id": "439", "type": "class", "data": "{\"code_str\": \"from contextlib import contextmanager\\n\\nclass Input:\\n    def __init__(self, text='', focus_parent=world.focus, multiline=False, tabs=False,\\n                 expandtab=True, tabstop=4, min_lines=3,\\n                 wrap_lines=True, syntax_coloring=False,\\n                 chars_per_line=None, max_lines=20, actions=None):\\n        self.dropped = False\\n        self.hud = False\\n        self.actions = actions\\n        self.multiline = multiline\\n        self.tabs = tabs\\n        self.expandtab = expandtab\\n        self.tabstop = tabstop\\n        self.chars_per_line = (80 if self.multiline else 8) if chars_per_line is None else chars_per_line\\n        self.max_lines = max_lines if self.multiline else 1\\n        self.min_lines = min_lines if self.multiline else 1\\n        self.num_lines = self.min_lines\\n        self.wrap_lines = wrap_lines\\n        self.inserting = False\\n        self.unsubmitted_change = False\\n        self.centered = not self.multiline\\n\\n        self.style = z.TextStyle(color=world.themes.theme.input_foreground_color)\\n\\n        self.submitted = z.Signal()\\n        self.changed = z.Signal()\\n\\n        self.widget_actions = [\\n            ('yank', lambda: Y(self.text)),\\n            ('paste', lambda: self.set_text(str(world.apps['Store']['registers']['default']))),\\n            ('clear', lambda: self.set_text(''))\\n        ]\\n\\n        self.hovered = False\\n        self.focused = False\\n        world.apps['Hoverables'].add_hoverable(self)\\n        world.apps['Clickables'].register(self)\\n        world.apps['Clickables'].register_right_click(self)\\n\\n        self.rectangle = z.RRectangle(color=world.themes.theme.input_background_color)\\n\\n        self.input_text = z.InputText(self, style=self.style, hud=self.hud,\\n                                      syntax_coloring=syntax_coloring)\\n        self.padding = z.Padding(self.input_text.layout, (0.5, 0.5))\\n        self.aligned = z.Aligned(self.padding.layout, axis='y',\\n                                 alignment='center' if self.centered else 'stretch')\\n        self.layout = self.aligned.layout\\n\\n        self.focus = focus_parent.add_child(self, on_changed=self.on_focus_changed)\\n\\n        self.set_text(text, emit_changed=False)\\n\\n    def set_hud(self, hud):\\n        self.input_text.set_hud(hud)\\n        self.hud = hud\\n\\n    def show_caret(self):\\n        self.input_text.show_caret()\\n\\n    def hide_caret(self):\\n        self.input_text.hide_caret()\\n\\n    def update_visible_text(self):\\n        self.input_text.update_visible_text()\\n\\n    def update_rectangle(self):\\n        self.rectangle.set_size(self.layout.size)\\n        self.rectangle.set_rotation(self.layout.rotation)\\n        self.rectangle.set_position(self.layout.position)\\n        self.rectangle.set_depth_offset_index(self.layout.depth_offset_index)\\n        self.rectangle.update()\\n\\n    def on_hovered(self, entered):\\n        if entered:\\n            world.apps['SystemCursors'].set_cursor('ibeam')\\n        else:\\n            world.apps['SystemCursors'].set_cursor('arrow')\\n        self.hovered = entered\\n\\n    def intersect(self, ray):\\n        return self.layout.intersect(ray)\\n\\n    def on_click(self, pos, ray, intersection):\\n        world.focus.set_focus(self.focus)\\n\\n    def on_double_click(self, pos, ray, intersection):\\n        #world.vim.set_current_mode('insert')\\n        value = world.apps['Dialogs'].edit_string(self.text)\\n        if value is not None:\\n            self.set_text(value)\\n            self.submit()\\n\\n    def on_right_click(self, pos, ray, intersection):\\n        actions = self.widget_actions if sdl2.SDLK_LSHIFT in world.window.keys or sdl2.SDLK_RSHIFT in world.window.keys else self.actions\\n        world.apps['Menus'].create_menu(actions, focus_parent=self.focus,\\n                                position=intersection - ray.direction * 0.2\\n                                #position=self.layout.position if position is None else position\\n                               ).show()\\n\\n    def on_focus_changed(self, focused):\\n        self.focused = focused\\n        if focused:\\n            world.vim.modes['insert'].set_input(self)\\n            world.vim.modes['normal'].set_input(self)\\n            #world.vim.modes['normal'].add_action_group(z.VimActionGroup('input', [\\n            #    z.VimAction('insert', self.set_current_vim_mode_insert, sdl2.SDLK_i),\\n            #]))\\n            self.show_caret()\\n        else:\\n            world.vim.set_current_mode('normal')\\n            world.vim.modes['insert'].set_input(None)\\n            world.vim.modes['normal'].set_input(None)\\n            self.hide_caret()\\n        self.update_background_color()\\n\\n    @contextmanager\\n    def inserting_ensured(self):\\n        prev = self.inserting\\n        self.set_inserting(True)\\n        try:\\n            yield\\n        finally:\\n            self.set_inserting(prev)\\n\\n    def set_inserting(self, inserting):\\n        if inserting != self.inserting:\\n            self.inserting = inserting\\n            if not self.inserting:\\n                self.move_caret('left')\\n\\n    def set_text(self, text, emit_changed=True):\\n        self.text = text\\n        self.lines = self.text.split('\\\\n')\\n        if not self.lines:\\n            self.lines.append('')\\n        self.scroll_offset = [0, 0]\\n        self.caret_location = [0, 0]\\n        if emit_changed:\\n            self.text_changed()\\n        self.update_visible_text()\\n\\n    def update_background_color(self):\\n        if self.focused:\\n            color = world.themes.theme.focused_background_color\\n        else:\\n            color = world.themes.theme.input_background_color\\n        self.rectangle.set_color(util.adjust_perceptual_color_brightness(\\n            color, 0.03 if self.unsubmitted_change else 0.0))\\n        self.rectangle.update()\\n\\n    def text_changed(self):\\n        self.changed.emit(self.text)\\n        self.unsubmitted_change = True\\n        self.update_background_color()\\n\\n    def submit(self):\\n        self.submitted.emit()\\n        self.unsubmitted_change = False\\n        self.update_background_color()\\n\\n    def move_caret(self, direction, amount=1):\\n        location = self.caret_location.copy()\\n        if direction == 'up':\\n            location[1] -= amount\\n        elif direction == 'down':\\n            location[1] += amount\\n        elif direction == 'left':\\n            location[0] -= amount\\n        elif direction == 'right':\\n            location[0] += amount\\n        self.move_caret_to(location)\\n\\n    def set_chars_per_line(self, chars_per_line):\\n        self.chars_per_line = chars_per_line\\n        self.scroll_offset[0] = max(self.caret_location[0] - self.chars_per_line + (0 if self.inserting else 1),\\n                                    min(self.scroll_offset[0], self.caret_location[0]))\\n\\n    def set_num_lines(self, num_lines):\\n        self.num_lines = num_lines\\n        self.scroll_offset[1] = max(self.caret_location[1] - self.num_lines + 1,\\n                                    min(self.scroll_offset[1], self.caret_location[1]))\\n\\n    def move_caret_to(self, location):\\n        old_scroll_offset = self.scroll_offset.copy()\\n        # Boundary adjustments\\n        self.caret_location[1] = max(0, min(location[1], len(self.lines) - 1))\\n        self.scroll_offset[1] = max(self.caret_location[1] - self.num_lines + 1,\\n                                    min(self.scroll_offset[1], self.caret_location[1]))\\n        current_line_length = len(self.lines[self.caret_location[1]])\\n\\n        self.caret_location[0] = max(0, min(\\n            location[0], current_line_length if self.inserting else current_line_length - 1))\\n        self.scroll_offset[0] = max(self.caret_location[0] - self.chars_per_line + (0 if self.inserting else 1),\\n                                    min(self.scroll_offset[0], self.caret_location[0]))\\n        if self.scroll_offset != old_scroll_offset:\\n            self.update_visible_text()\\n        else:\\n            self.input_text.update_caret_rectangle()\\n\\n    def center_current_line(self):\\n        self.scroll_offset[1] = max(0, self.caret_location[1] - self.num_lines // 2 + 1)\\n        self.update_visible_text()\\n\\n    def move_caret_to_line_start(self):\\n        self.move_caret_to((0, self.caret_location[1]))\\n\\n    def move_caret_to_line_end(self):\\n        self.move_caret_to((len(self.lines[self.caret_location[1]])-1, self.caret_location[1]))\\n\\n    def move_caret_to_last_line(self):\\n        self.move_caret_to((self.caret_location[0], len(self.lines)-1))\\n\\n    def move_caret_to_first_line(self):\\n        self.move_caret_to((self.caret_location[0], 0))\\n\\n    def move_caret_to_end(self):\\n        self.move_caret_to((len(self.lines[-1]), len(self.lines)))\\n\\n    def is_word_char(self, char):\\n        return char.isalnum() or char == '_'\\n\\n    def move_caret_to_next_word(self):\\n        line = self.lines[self.caret_location[1]]\\n        for i in range(self.caret_location[0]+1, len(line)):\\n            if self.is_word_char(line[i]) != self.is_word_char(line[self.caret_location[0]]):\\n                for j in range(i, len(line)):\\n                    if not line[j].isspace():\\n                        self.move_caret_to((j, self.caret_location[1]))\\n                        return\\n        for i in range(self.caret_location[1]+1, len(self.lines)):\\n            line = self.lines[i]\\n            for j in range(0, len(line)):\\n                if not line[j].isspace():\\n                    self.move_caret_to((j, i))\\n                    return\\n\\n    def move_caret_to_previous_word(self):\\n        line = self.lines[self.caret_location[1]]\\n        for i in range(self.caret_location[0]-1, -1, -1):\\n            if not line[i].isspace():\\n                for j in range(i, -1, -1):\\n                    if self.is_word_char(line[j]) != self.is_word_char(line[i]) or line[j].isspace():\\n                        self.move_caret_to((j+1, self.caret_location[1]))\\n                        return\\n                else:\\n                    self.move_caret_to((0, self.caret_location[1]))\\n                    return\\n        for i in range(self.caret_location[1]-1, -1, -1):\\n            line = self.lines[i]\\n            for j in range(len(line)-1, -1, -1):\\n                if not line[j].isspace():\\n                    for k in range(j, -1, -1):\\n                        if not self.is_word_char(line[k]) == self.is_word_char(line[j]):\\n                            self.move_caret_to((k+1, i))\\n                            return\\n\\n    def delete_n_next_words(self, n):\\n        line = self.lines[self.caret_location[1]]\\n        start = end = self.caret_location[0]\\n        for _ in range(n):\\n            for i in range(end + 1, len(line)):\\n                if self.is_word_char(line[i]) != self.is_word_char(line[end]):\\n                    break\\n            else:\\n                end = len(line)\\n                break\\n            end = i\\n            for i in range(end, len(line)):\\n                if not line[i].isspace():\\n                    break\\n            end = i\\n            if end >= len(line):\\n                break\\n        self.lines[self.caret_location[1]] = line[:self.caret_location[0]] + line[end:]\\n        self.lines_changed()\\n\\n    def search(self, text, reverse=False):\\n        \\\"\\\"\\\"Move caret to next occurrence of text, loop back to beginning if necessary.\\\"\\\"\\\"\\n        search_text = text.lower()\\n        if not reverse:\\n            for i in range(self.caret_location[1], len(self.lines)):\\n                line = self.lines[i]\\n                for j in range(self.caret_location[0] + 1, len(line)):\\n                    if line[j:].lower().startswith(search_text):\\n                        self.move_caret_to((j, i))\\n                        return\\n            for i in range(0, self.caret_location[1]):\\n                line = self.lines[i]\\n                for j in range(0, len(line)):\\n                    if line[j:].lower().startswith(search_text):\\n                        self.move_caret_to((j, i))\\n                        return\\n        else:\\n            # TODO this doesn't work\\n            for i in range(self.caret_location[1], -1, -1):\\n                line = self.lines[i]\\n                for j in range(self.caret_location[0] - 1, -1, -1):\\n                    if line[j::-1].lower().startswith(search_text):\\n                        self.move_caret_to((j, i))\\n                        return\\n            for i in range(len(self.lines)-1, self.caret_location[1], -1):\\n                line = self.lines[i]\\n                for j in range(len(line)-1, -1, -1):\\n                    if line[j::-1].lower().startswith(search_text):\\n                        self.move_caret_to((j, i))\\n                        return\\n\\n    def match_indent(self):\\n        indent = 0\\n        if self.caret_location[1] > 0:\\n            prev_line = self.lines[self.caret_location[1]-1]\\n            indent = len(prev_line) - len(prev_line.lstrip(' '))\\n        self.lines[self.caret_location[1]] = ' ' * indent + self.lines[self.caret_location[1]].lstrip(' ')\\n        self.lines_changed()\\n        self.move_caret_to((indent, self.caret_location[1]))\\n\\n    def insert_char(self, char, move_caret=True, trigger_update=True):\\n        line = self.lines[self.caret_location[1]]\\n        if char == '\\\\n':\\n            self.lines[self.caret_location[1]] = line[:self.caret_location[0]]\\n            self.lines.insert(self.caret_location[1] + 1, line[self.caret_location[0]:])\\n            if move_caret:\\n                self.move_caret_to((0, self.caret_location[1] + 1))\\n        else:\\n            new_line = line[:self.caret_location[0]] + char + line[self.caret_location[0]:]\\n            self.lines[self.caret_location[1]] = new_line\\n            if move_caret:\\n                self.move_caret('right', 1)\\n        if trigger_update:\\n            self.lines_changed()\\n\\n    def insert_text(self, text, linewise=False):\\n        with self.inserting_ensured():\\n            if linewise:\\n                self.move_caret_to((\\n                    len(self.lines[self.caret_location[1]]),\\n                    self.caret_location[1]\\n                ))\\n                self.insert_char('\\\\n', trigger_update=False)\\n            for char in text:\\n                self.insert_char(char, move_caret=True, trigger_update=False)\\n        self.lines_changed()\\n\\n    def delete_char(self, direction='left'):\\n        #self.lines = self.text.split('\\\\n')\\n        line = self.lines[self.caret_location[1]]\\n\\n        # Delete character to the left of the caret (backspace operation)\\n        if direction == 'left':\\n            if self.caret_location[0] > 0:\\n                new_line = line[:self.caret_location[0]-1] + line[self.caret_location[0]:]\\n                self.lines[self.caret_location[1]] = new_line\\n                self.move_caret('left', 1)\\n            elif self.caret_location[1] > 0: # has previous line\\n                new_location = (len(self.lines[self.caret_location[1]-1])-(0 if self.inserting else 1), self.caret_location[1]-1)\\n                self.lines[self.caret_location[1] - 1] += self.lines[self.caret_location[1]]\\n                del self.lines[self.caret_location[1]]\\n                self.move_caret_to(new_location)\\n         # Delete character to the right of the caret (delete operation)\\n        elif direction == 'right' and self.caret_location[0] < len(line):\\n            new_line = line[:self.caret_location[0]] + line[self.caret_location[0]+1:]\\n            self.lines[self.caret_location[1]] = new_line\\n\\n        self.lines_changed()\\n\\n    def lines_changed(self):\\n        self.text = '\\\\n'.join(self.lines)\\n        self.text_changed()\\n        self.update_visible_text()\\n\\n    def get_lines(self, n):\\n        return self.lines[self.caret_location[1]:self.caret_location[1]+n]\\n\\n    def delete_lines(self, n):\\n        if len(self.lines) > 1:\\n            del self.lines[self.caret_location[1]:self.caret_location[1]+n]\\n            if not self.lines:\\n                self.lines.append('')\\n        else:\\n            self.lines = ['']\\n        self.text = '\\\\n'.join(self.lines)\\n        self.text_changed()\\n        self.update_visible_text()\\n        self.move_caret_to(self.caret_location)\\n\\n    def drop(self):\\n        world.apps['Clickables'].unregister(self)\\n        world.apps['Clickables'].unregister_right_click(self)\\n        if self.focus:\\n            self.focus.disconnect()\\n        self.aligned.drop()\\n        self.padding.drop()\\n        self.input_text.drop()\\n        self.rectangle.drop()\\n        world.apps['Hoverables'].remove_hoverable(self)\\n        self.focus.drop()\\n        self.dropped = True\\n\", \"name\": \"Input\"}", "created_at": null, "updated_at": 1756754129.7230022}