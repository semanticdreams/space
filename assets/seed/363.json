{"id": "363", "type": "class", "data": "{\"code_str\": \"class ViewportAlignment:\\n    def __init__(self, distance=120, padding=0, projection=None):\\n        self.distance = distance\\n        self.padding = padding\\n        self.world = world\\n        self.projection = projection or world.projection\\n        self.width, self.height = self.viewport_dimensions()\\n\\n    def viewport_dimensions(self):\\n        h = 2 * self.distance * math.tan(math.radians(self.projection.fov) / 2)\\n        w = h * self.projection.aspect\\n        return w, h\\n\\n    def align_to_viewport(self, target=[0, 0, 0]):\\n        return [\\n            (target[0] + self.width / 2) - self.padding,\\n            (target[1] - self.height / 2) + self.padding,\\n            target[2] + self.distance\\n        ]\\n\\n    def max_target_size(self):\\n        max_width = self.width - 2 * self.padding\\n        max_height = self.height - 2 * self.padding\\n        return max_width, max_height\\n\\n    def distance_for_target_size(self, target_width, target_height, padding=0):\\n        padded_width = target_width + 2 * padding\\n        padded_height = target_height + 2 * padding\\n\\n        target_aspect = padded_width / padded_height\\n        distance_width = (padded_width / 2) / math.tan(math.radians(self.projection.aspect * self.projection.fov) / 2)\\n        distance_height = (padded_height / 2) / math.tan(math.radians(self.projection.fov) / 2)\\n\\n        # Choose the maximum distance to ensure both dimensions fit within the viewport\\n        distance = max(distance_width, distance_height)\\n        return distance\", \"name\": \"ViewportAlignment\"}", "created_at": null, "updated_at": 1754736945.48266}