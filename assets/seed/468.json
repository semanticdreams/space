{"id": "468", "type": "class", "data": "{\"code_str\": \"import sdl2\\nimport sdl2.ext\\nimport numpy as np\\nfrom OpenGL.GL import *\\nfrom OpenGL.GL.shaders import compileProgram, compileShader\\nimport glm\\nimport ctypes\\nimport time\\n\\n\\nVERTEX_SHADER = \\\"\\\"\\\"\\n#version 330 core\\nlayout(location = 0) in vec3 position;\\nlayout(location = 1) in mat4 model;\\n\\nuniform mat4 view;\\nuniform mat4 projection;\\n\\nout vec3 fragWorldPos;\\nflat out int instanceID;\\n\\nvoid main() {\\n    vec4 worldPos = model * vec4(position, 1.0);\\n    fragWorldPos = worldPos.xyz;\\n    instanceID = gl_InstanceID;\\n    gl_Position = projection * view * worldPos;\\n}\\n\\\"\\\"\\\"\\n\\nFRAGMENT_SHADER = \\\"\\\"\\\"\\n#version 330 core\\nin vec3 fragWorldPos;\\nflat in int instanceID;\\n\\nuniform mat4 inverseClipTransforms[100];\\n\\nout vec4 FragColor;\\n\\nvoid main() {\\n    vec3 localPos = (inverseClipTransforms[instanceID] * vec4(fragWorldPos, 1.0)).xyz;\\n\\n    if (abs(localPos.x) > 0.5 || abs(localPos.y) > 0.5 || abs(localPos.z) > 0.5) {\\n        discard;\\n    }\\n\\n    FragColor = vec4(0.2 + 0.6 * float(instanceID % 2), 0.6, 1.0, 1.0);\\n}\\n\\\"\\\"\\\"\\n\\n\\n# ---------- Geometry ----------\\nquad_vertices = np.array([\\n    -0.5, -0.5, 0.0,\\n     0.5, -0.5, 0.0,\\n     0.5,  0.5, 0.0,\\n    -0.5,  0.5, 0.0\\n], dtype=np.float32)\\n\\nquad_indices = np.array([0, 1, 2, 2, 3, 0], dtype=np.uint32)\\n\\n\\nclass Scroll:\\n    def __init__(self):\\n        self.shader = compileProgram(\\n            compileShader(VERTEX_SHADER, GL_VERTEX_SHADER),\\n            compileShader(FRAGMENT_SHADER, GL_FRAGMENT_SHADER)\\n        )\\n        self.vao = glGenVertexArrays(1)\\n        self.vbo = glGenBuffers(1)\\n        self.ebo = glGenBuffers(1)\\n        self.instanceVBO = glGenBuffers(1)\\n\\n        glBindVertexArray(self.vao)\\n\\n        glBindBuffer(GL_ARRAY_BUFFER, self.vbo)\\n        glBufferData(GL_ARRAY_BUFFER, quad_vertices.nbytes, quad_vertices, GL_STATIC_DRAW)\\n\\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.ebo)\\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, quad_indices.nbytes, quad_indices, GL_STATIC_DRAW)\\n\\n        # Position attribute\\n        glEnableVertexAttribArray(0)\\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, ctypes.c_void_p(0))\\n\\n        # Instance Model Matrices\\n        glBindBuffer(GL_ARRAY_BUFFER, self.instanceVBO)\\n        glBufferData(GL_ARRAY_BUFFER, 100 * 64, None, GL_DYNAMIC_DRAW)\\n\\n        for i in range(4):\\n            glEnableVertexAttribArray(1 + i)\\n            glVertexAttribPointer(1 + i, 4, GL_FLOAT, GL_FALSE, 64, ctypes.c_void_p(i * 16))\\n            glVertexAttribDivisor(1 + i, 1)\\n\\n        glBindVertexArray(0)\\n\\n        # ---------- Uniforms ----------\\n        glUseProgram(self.shader)\\n        self.viewLoc = glGetUniformLocation(self.shader, \\\"view\\\")\\n        self.projLoc = glGetUniformLocation(self.shader, \\\"projection\\\")\\n        self.inverseClipLoc = glGetUniformLocation(self.shader, \\\"inverseClipTransforms\\\")\\n\\n        # ---------- Main Loop ----------\\n        self.NUM_INSTANCES = 10\\n        self.running = True\\n        self.start_time = time.time()\\n\\n    def update(self):\\n        glUseProgram(self.shader)\\n\\n        width, height = 800, 600\\n        view = glm.lookAt(glm.vec3(0, 0, 5), glm.vec3(0, 0, 0), glm.vec3(0, 1, 0))\\n        proj = glm.perspective(glm.radians(45.0), width / height, 0.1, 100.0)\\n\\n        glUniformMatrix4fv(self.viewLoc, 1, GL_FALSE, glm.value_ptr(view))\\n        glUniformMatrix4fv(self.projLoc, 1, GL_FALSE, glm.value_ptr(proj))\\n\\n        model_matrices = []\\n        inverse_clip_matrices = []\\n        current_time = time.time() - self.start_time\\n\\n        for i in range(self.NUM_INSTANCES):\\n            angle = current_time + i\\n            pos = glm.vec3((i % 5) - 2.0, (i // 5) - 0.5, 0)\\n            model = glm.translate(glm.mat4(1.0), pos)\\n            model = glm.rotate(model, angle, glm.vec3(0, 0, 1))\\n            model_matrices.append(model)\\n            inverse_clip_matrices.append(glm.inverse(model))\\n\\n        model_data = np.array([np.array(m.to_list(), dtype=np.float32) for m in model_matrices])\\n        glBindBuffer(GL_ARRAY_BUFFER, self.instanceVBO)\\n        glBufferSubData(GL_ARRAY_BUFFER, 0, model_data.nbytes, model_data)\\n\\n        flat_inverse = np.array([m.to_list() for m in inverse_clp_matrices], dtype=np.float32).reshape(-1)\\n        glUniformMatrix4fv(self.inverseClipLoc, self.NUM_INSTANCES, GL_FALSE, flat_inverse)\\n\\n        glBindVertexArray(self.vao)\\n        glDrawElementsInstanced(GL_TRIANGLES, 6, GL_UNSIGNED_INT, None, self.NUM_INSTANCES)\\n        glBindVertexArray(0)\\n\\n    def drop(self):\\n        glDeleteVertexArrays(1, [self.vao])\\n        glDeleteBffers(1, [self.vbo, self.ebo, self.instanceVBO])\\n        glDeleteProgram(self.shader)\", \"name\": \"Scroll\"}", "created_at": null, "updated_at": 1751906432.7453692}