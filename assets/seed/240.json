{"id": "240", "type": "class", "data": "{\"code_str\": \"class Layout(z.Droppable):\\n    @staticmethod\\n    def parse_axis(s):\\n        return {'x': 0, 'y': 1, 'z': 2}.get(s, s)\\n\\n    @staticmethod\\n    def parse_axes(axes):\\n        return tuple(Layout.parse_axis(axis) for axis in axes)\\n\\n    def __init__(self, children=None, measurer=None, layouter=None,\\n                 uses_child_measures=True, name=None, intersect=None):\\n        self.dropped = False\\n        self.uses_child_measures = uses_child_measures\\n        self.parent = None\\n        self.root = None\\n        self.name = name\\n        self.children = []\\n        self.position = np.array((0, 0, 0), float)\\n        self.rotation = np.array((1, 0, 0, 0), float)\\n        self.measure = np.array((0, 0, 0), float)\\n        self.size = np.array((0, 0, 0), float)\\n        self.depth_offset_index = 0\\n        self.measure_dirty = False\\n        self.layout_dirty = False\\n\\n        self.measurer = measurer\\n        self.layouter = layouter\\n\\n        if intersect:\\n            self.intersect = intersect\\n\\n        self.set_children(children or [])\\n\\n    def __str__(self):\\n        return f'Layout({self.name})'\\n\\n    def dump(self, indent=0):\\n        print(' ' * indent, self.name, self.position, self.size)\\n        for child in self.children:\\n            child.dump(indent + 1)\\n\\n    def set_children(self, children):\\n        self.clear_children()\\n        self.add_children(children)\\n\\n    def clear_children(self):\\n        if self.children:\\n            for child in list(self.children):\\n                self.remove_child(child)\\n\\n    def add_children(self, children):\\n        for child in children:\\n            self.add_child(child)\\n\\n    def add_child(self, child):\\n        child.parent = self\\n        child.set_root(self.root)\\n        self.children.append(child)\\n\\n    def remove_child(self, child):\\n        child.parent = None\\n        child.set_root(None)\\n        self.children.remove(child)\\n\\n    def set_position(self, position):\\n        self.position = position\\n        self.mark_layout_dirty()\\n\\n    def get_position(self):\\n        return self.position\\n\\n    def get_rotation(self):\\n        return self.rotation\\n\\n    def set_rotation(self, rotation):\\n        self.rotation = rotation\\n        self.mark_layout_dirty()\\n\\n    def set_root(self, root):\\n        stack = [self]\\n        while stack:\\n            node = stack.pop()\\n            stack.extend(node.children)\\n            if root:\\n                if node.measure_dirty:\\n                    root.measure_dirt.add(node)\\n                    node.measure_dirty = False\\n                if node.layout_dirty:\\n                    root.layout_dirt.add(node)\\n                    node.layout_dirty = False\\n            elif node.root:\\n                node.root.measure_dirt.discard(node)\\n                node.root.layout_dirt.discard(node)\\n            node.root = root\\n\\n\\n    def mark_layout_dirty(self):\\n        if self.root:\\n            self.root.layout_dirt.add(self)\\n        else:\\n            self.layout_dirty = True\\n\\n    def mark_measure_dirty(self):\\n        if self.root:\\n            self.root.measure_dirt.add(self)\\n        else:\\n            self.measure_dirty = True\\n\\n    def drop(self):\\n        self.clear_children()\\n        if self.root:\\n            self.root.measure_dirt.discard(self)\\n            self.root.layout_dirt.discard(self)\\n        self.dropped = True\\n\\n    def intersect(self, ray):\\n        # Get the rotation matrix from the quaternion and remove the translation part\\n        rotation_matrix = transformations.quaternion_matrix(self.rotation)[:-1, :-1]\\n        inverse_rotation_matrix = np.linalg.inv(rotation_matrix)\\n\\n        # Transform the ray's origin and direction into the local space of the object\\n        ray_origin_local = np.dot(inverse_rotation_matrix, ray.origin - self.position)\\n        ray_direction_local = np.dot(inverse_rotation_matrix, ray.direction)\\n\\n        # The AABB's bounds in local coordinates (since the object's position is at the bottom-left corner)\\n        # The size in local space is now a 3D vector\\n        min_bounds = np.array([0, 0, 0])  # Bottom-left-front corner at the origin\\n        max_bounds = np.array([self.size[0], self.size[1], self.size[2]])  # Full width, height, and depth\\n\\n        tmin, tmax = -np.inf, np.inf\\n\\n        # Traverse through each axis (x, y, z)\\n        for i in range(3):  # x, y, z axes\\n            # If the ray direction along the axis is non-zero, calculate intersections\\n            if ray_direction_local[i] != 0:\\n                t1 = (min_bounds[i] - ray_origin_local[i]) / ray_direction_local[i]\\n                t2 = (max_bounds[i] - ray_origin_local[i]) / ray_direction_local[i]\\n\\n                # Ensure t1 is the smaller and t2 is the larger value\\n                if t1 > t2:\\n                    t1, t2 = t2, t1\\n\\n                # Update tmin and tmax\\n                tmin = max(tmin, t1)\\n                tmax = min(tmax, t2)\\n\\n                # If tmin > tmax, there is no intersection\\n                if tmin > tmax:\\n                    return False, None, None\\n\\n        # If we pass all checks, compute the intersection point and the distance\\n        intersection_point_local = ray_origin_local + tmin * ray_direction_local\\n\\n        # Adjust the intersection point to account for the object's position in world coordinates\\n        intersection_point_world = np.dot(rotation_matrix, intersection_point_local) + self.position\\n\\n        # Compute the distance from the ray origin to the intersection point\\n        distance = np.linalg.norm(intersection_point_world - ray.origin)\\n\\n        return True, intersection_point_world, distance\\n\", \"name\": \"Layout\"}", "created_at": null, "updated_at": 1751906432.7392054}