{"id": "4c6d7a38-864b-468e-a630-9873cd5a6887", "type": "class", "data": "{\"code_str\": \"import numpy as np\\n\\nclass FlatTerrain:\\n    def __init__(self, width=50, length=50, position=None, scale=None, opacity=1.0):\\n        self.width = width\\n        self.length = length\\n        self.position = np.array(position) if position is not None else np.array([-500, -100, -500])\\n        self.scale = np.array(scale) if scale is not None else np.array([20, 1, 20])\\n        self.opacity = opacity\\n\\n        # Precompute vertices count:\\n        # Each square has 2 triangles, each triangle has 3 vertices -> 6 vertices per square\\n        num_squares = width * length\\n        num_vertices = num_squares * 6\\n\\n        # Create the vertex array: (num_vertices, 8) -> [x, y, z, r, g, b, a, extra]\\n        self.vertices = np.zeros((num_vertices, 8), dtype=np.float32)\\n\\n        self._generate_triangles()\\n\\n        self.triangle_vector = world.renderers.scene_triangle_vector\\n        self.handle = self.triangle_vector.allocate(self.vertices.size)\\n        self.update_positions()\\n\\n    def _generate_triangles(self):\\n        # Create grid coords for squares\\n        xs = np.arange(self.width)\\n        ys = np.arange(self.length)\\n        xs_grid, ys_grid = np.meshgrid(xs, ys, indexing='ij')  # shape (width, length)\\n\\n        # Flatten for iteration\\n        xs_flat = xs_grid.flatten()\\n        ys_flat = ys_grid.flatten()\\n\\n        # Compute base index for each square's 6 vertices in the big array\\n        base_idx = np.arange(xs_flat.size) * 6\\n\\n        # Define relative coords for the two triangles per square\\n        # Triangle 1 vertices: a(x,y), b(x+1,y), c(x,y+1)\\n        tri1 = np.array([[0, 0], [1, 0], [0, 1]])\\n        # Triangle 2 vertices: b(x+1,y), d(x+1,y+1), c(x,y+1)\\n        tri2 = np.array([[1, 0], [1, 1], [0, 1]])\\n\\n        # Precompute positions for all vertices\\n        # For each square, we have 6 vertices (2 triangles)\\n        vertices_xy = np.concatenate((tri1, tri2), axis=0)  # shape (6,2)\\n\\n        # Repeat for all squares\\n        all_offsets = (vertices_xy[np.newaxis, :, :] +\\n                       np.stack((xs_flat[:, np.newaxis], ys_flat[:, np.newaxis]), axis=2)).reshape(-1, 2)\\n\\n        # Set vertex positions: x, y, z\\n        self.vertices[:, 0] = all_offsets[:, 0]  # x\\n        self.vertices[:, 1] = 0                   # y (flat)\\n        self.vertices[:, 2] = all_offsets[:, 1]  # z\\n\\n        # Compute colors: checkerboard pattern for each square, repeated 6 times per square\\n        # For color indexing, use the (x + y) of the square, not vertex coords\\n        checker = (xs_flat + ys_flat) % 2  # 0 or 1 for each square\\n        colors_dark = np.array([0.3, 0.3, 0.3, 1.0], dtype=np.float32)\\n        colors_light = np.array([0.7, 0.7, 0.7, 1.0], dtype=np.float32)\\n\\n        # Repeat color 6 times per square (6 vertices)\\n        colors = np.where(checker[:, None], colors_light, colors_dark)  # shape (num_squares, 4)\\n        colors_repeated = np.repeat(colors, 6, axis=0)                   # shape (num_vertices, 4)\\n\\n        # Set color components\\n        self.vertices[:, 3:7] = colors_repeated\\n\\n        # Extra attribute (set to zero)\\n        self.vertices[:, 7] = 0\\n\\n    def update_positions(self):\\n        v = self.triangle_vector.view(self.handle).reshape(-1, 8)\\n        # Scale and translate positions (x, y, z)\\n        v[:, :3] = self.vertices[:, :3] * self.scale + self.position\\n        # Copy colors (r, g, b, a) as-is from precomputed vertices\\n        v[:, 3:7] = self.vertices[:, 3:7]\\n        # Set opacity (override alpha channel)\\n        v[:, 6] = self.opacity\\n\\n    def drop(self):\\n        self.triangle_vector.delete(self.handle)\", \"name\": \"FlatTerrain\"}", "created_at": null, "updated_at": 1751906432.748332}