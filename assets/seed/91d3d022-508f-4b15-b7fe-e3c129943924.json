{"id": "91d3d022-508f-4b15-b7fe-e3c129943924", "type": "class", "data": "{\"code_str\": \"class PerlinTerrain:\\n    def __init__(self, width=300, length=300, position=None, scale=None, opacity=0.7):\\n        self.width = width\\n        self.length = length\\n        self.position = np.array(position) if position is not None else np.array([0, -100, 0])\\n        self.scale = np.array(scale) if scale is not None else np.array([5, 2, 5])\\n        self.opacity = opacity\\n\\n        # Noise divisors and scales for mountains, boulders, rocks\\n        self.n1div, self.n2div, self.n3div = 30, 4, 1\\n        self.n1scale, self.n2scale, self.n3scale = 20, 2, 1\\n        self.zroot, self.zpower = 2, 2.5\\n\\n        # Color map\\n        self.colors = {\\n            0: (0, 0, 1, 1),\\n            1: (1, 1, 0, 1),\\n            20: (0, 1, 0, 1),\\n            25: (0.5, 0.5, 0.5, 1),\\n            1000: (1, 1, 1, 1)\\n        }\\n\\n        # Perlin noise generators\\n        self.noise1 = z.PerlinNoise(self.width / self.n1div, self.length / self.n1div)\\n        self.noise2 = z.PerlinNoise(self.width / self.n2div, self.length / self.n2div)\\n        self.noise3 = z.PerlinNoise(self.width / self.n3div, self.length / self.n3div)\\n\\n        self.points = []\\n        self.triangles = []\\n\\n        self.vertices = self._generate_triangles()\\n        self.triangle_vector = world.renderers.scene_triangle_vector\\n        self.handle = self.triangle_vector.allocate(self.vertices.size)\\n        self.update_positions()\\n\\n    def _get_color(self, a, b, c):\\n        z = (self.points[a][1] + self.points[b][1] + self.points[c][1]) / 3\\n        for height in sorted(self.colors.keys()):\\n            if z <= height:\\n                return self.colors[height]\\n        return self.colors[max(self.colors.keys())]\\n\\n    def _generate_triangles(self):\\n        # Generate terrain height points\\n        for x in range(-self.width // 2, self.width // 2):\\n            for y in range(-self.length // 2, self.length // 2):\\n                x1 = x + self.width / 2\\n                y1 = y + self.length / 2\\n                z = (\\n                    self.noise1.perlin(x1 / self.n1div, y1 / self.n1div) * self.n1scale +\\n                    self.noise2.perlin(x1 / self.n2div, y1 / self.n2div) * self.n2scale +\\n                    self.noise3.perlin(x1 / self.n3div, y1 / self.n3div) * self.n3scale\\n                )\\n\\n                if z >= 0:\\n                    z = -math.sqrt(z)\\n                else:\\n                    z = ((-z) ** (1 / self.zroot)) ** self.zpower\\n\\n                self.points.append([x, z, y])\\n\\n        # Generate triangles and associated vertex data\\n        for x in range(self.width):\\n            for y in range(self.length):\\n                idx = x * self.length + y\\n                if x > 0 and y > 0:\\n                    a, b, c = idx, idx - 1, (x - 1) * self.length + y\\n                    self.triangles.append([a, b, c, self._get_color(a, b, c)])\\n                if x < self.width - 1 and y < self.length - 1:\\n                    a, b, c = idx, idx + 1, (x + 1) * self.length + y\\n                    self.triangles.append([a, b, c, self._get_color(a, b, c)])\\n\\n        # Flatten vertex data\\n        vertices = []\\n        for a, b, c, color in self.triangles:\\n            for idx in (a, b, c):\\n                vertices.extend([*self.points[idx], *color, 0])\\n        return np.array(vertices, dtype=float)\\n\\n    def update_positions(self):\\n        v = self.triangle_vector.view(self.handle)\\n        for i in range(0, self.vertices.size, 8):\\n            v[i:i+3] = self.vertices[i:i+3] * self.scale + self.position\\n            v[i+3:i+6] = self.vertices[i+3:i+6] / 5\\n            v[i+6] = self.opacity\\n\\n    def get_physics(self):\\n        points = np.array(self.points) * self.scale #+ self.position\\n        triangle_mesh = bt.TriangleMesh()\\n        for tri in self.triangles:\\n            a, b, c, _ = tri\\n            triangle_mesh.addTriangle(\\n                bt.Vector3(*points[a]),\\n                bt.Vector3(*points[b]),\\n                bt.Vector3(*points[c]),\\n                True\\n            )\\n        terrain_shape = bt.BvhTriangleMeshShape(triangle_mesh, True)\\n        transform = bt.Transform()\\n        transform.setIdentity()\\n        transform.setOrigin(bt.Vector3(*self.position))\\n        motion_state = bt.DefaultMotionState(transform)\\n        terrain_body = bt.RigidBody(bt.RigidBodyConstructionInfo(\\n            0, motion_state, terrain_shape, bt.Vector3(0, 0, 0)\\n        ))\\n        return triangle_mesh, terrain_shape, motion_state, terrain_body\\n\\n    def drop(self):\\n        self.triangle_vector.delete(self.handle)\", \"name\": \"PerlinTerrain\"}", "created_at": null, "updated_at": 1754736945.4773123}