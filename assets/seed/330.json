{"id": "330", "type": "class", "data": "{\"code_str\": \"class Spatiolation:\\n    def __init__(self):\\n        self.active_plane = z.Plane((0, 0, 1), (0, 0, 0))\\n\\n        self.spatiolatables = []\\n        self.moved_handlers = {}\\n\\n        self.drag = None\\n\\n        world.states.create_state(name='spatiolation', on_enter=self.on_enter,\\n                                  on_leave=self.on_leave)\\n\\n    def on_enter(self):\\n        world.window.mouse_button.connect(self.on_mouse_button)\\n        world.window.mouse_motion.connect(self.on_mouse_motion)\\n        world.window.keyboard.connect(self.on_keyboard)\\n\\n    def on_leave(self):\\n        world.window.mouse_button.disconnect(self.on_mouse_button)\\n        world.window.mouse_motion.disconnect(self.on_mouse_motion)\\n        world.window.keyboard.disconnect(self.on_keyboard)\\n\\n    def on_keyboard(self, key, scancode, action, mods):\\n        if action == 1:\\n            if key == sdl2.SDLK_ESCAPE:\\n                world.states.transit_back()\\n            elif key == sdl2.SDLK_0 and self.drag:\\n                self.drag.plane = self.active_plane\\n                self.update_spatiolatable_position()\\n            elif key == sdl2.SDLK_LEFT:\\n                o = world.focus.current.obj.spatiolator\\n                o.set_position(o.position + np.array((-10, 0, 0)))\\n            elif key == sdl2.SDLK_RIGHT:\\n                o = world.focus.current.obj.spatiolator\\n                o.set_position(o.position + np.array((10, 0, 0)))\\n            elif key == sdl2.SDLK_UP:\\n                o = world.focus.current.obj.spatiolator\\n                o.set_position(o.position + np.array((0, 10, 0)))\\n            elif key == sdl2.SDLK_DOWN:\\n                o = world.focus.current.obj.spatiolator\\n                o.set_position(o.position + np.array((0, -10, 0)))\\n\\n    def on_mouse_button(self, button, action, mods):\\n        if button == sdl2.SDL_BUTTON_LEFT:\\n            if action == 1:\\n                intersector = z.ScreenPosObjectsIntersector(\\n                    world.window.mouse_pos, self.spatiolatables)\\n                if intersector.nearest_hit:\\n                    start_pos = intersector.nearest_hit.intersection\\n                    forward_vector = world.camera.camera.get_forward()\\n                    axis_vectors = [np.array(v) for v in [(1, 0, 0), (0, 1, 0), (0, 0, 1), (-1, 0, 0), (0, -1, 0), (0, 0, -1)]]\\n                    closest_vector = max(axis_vectors, key=lambda v: np.dot(v, forward_vector))\\n                    plane = z.Plane(closest_vector, start_pos)\\n                    self.drag = z.DragMoveOperation(\\n                        intersector.nearest_hit.obj, start_pos,\\n                        intersector.nearest_hit.obj.get_position() - intersector.nearest_hit.intersection,\\n                        plane\\n                    )\\n            else:\\n                if self.drag:\\n                    if self.drag.spatiolator in self.moved_handlers:\\n                        self.moved_handlers[self.drag.spatiolator](self.drag)\\n                self.drag = None\\n\\n    def on_mouse_motion(self, x, y):\\n        if self.drag:\\n            self.update_spatiolatable_position()\\n\\n    def update_spatiolatable_position(self):\\n        ray = world.screen_pos_ray(world.window.mouse_pos)\\n        intersector = z.RayPlaneIntersector(ray, self.drag.plane)\\n        position = intersector.intersection + self.drag.offset\\n        self.drag.spatiolator.set_position(position)\\n\\n    def add_spatiolatable(self, obj, on_moved=None):\\n        self.spatiolatables.append(obj)\\n        if on_moved:\\n            self.moved_handlers[obj] = on_moved\\n\\n    def remove_spatiolatable(self, obj):\\n        self.spatiolatables.remove(obj)\\n\\n    def drop(self):\\n        pass\\n\", \"name\": \"Spatiolation\"}", "created_at": null, "updated_at": 1756754129.724962}