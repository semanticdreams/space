{"id": "361", "type": "class", "data": "{\"code_str\": \"from util import normalize\\n\\n\\nclass Camera:\\n    #__slots__ = 'position', 'rotation', 'view_matrix', 'dirty', 'changed'\\n\\n    def __init__(self, position, rotation):\\n        self.position = np.asarray(position, float)\\n        self.rotation = np.asarray(rotation, float)\\n\\n        self.view_matrix = None\\n\\n        self.changed = z.Signal()\\n\\n        self.dirty = {'position', 'rotation'}\\n\\n    def forward(self, x):\\n        #v = np.array((0.0, 0.0, 0.0, 1.0), float)\\n        #v = transformations.quaternion_multiply(\\n        #    transformations.quaternion_multiply(self.rotation, v),\\n        #    transformations.quaternion_conjugate(self.rotation))\\n        self.position += self.get_forward() * x\\n        self.dirty.add('position')\\n\\n    def right(self, x):\\n        #v = np.array((0.0, 1.0, 0.0, 0.0), float)\\n        #v = transformations.quaternion_multiply(\\n        #    transformations.quaternion_multiply(self.rotation, v),\\n        #    transformations.quaternion_conjugate(self.rotation))\\n        #self.position += v[1:] * x\\n        self.position += self.get_right() * x\\n        self.dirty.add('position')\\n\\n    def up(self, x):\\n        #v = np.array((0.0, 0.0, 1.0, 0.0), float)\\n        #v = transformations.quaternion_multiply(\\n        #    transformations.quaternion_multiply(self.rotation, v),\\n        #    transformations.quaternion_conjugate(self.rotation))\\n        self.position += self.get_up() * x\\n        self.dirty.add('position')\\n\\n    def yaw(self, angle):\\n        q = transformations.quaternion_about_axis(angle, [0, 1, 0])\\n        q = transformations.quaternion_multiply(q, self.rotation)\\n        q = q / np.linalg.norm(q)\\n        self.rotation = q\\n        self.dirty.add('rotation')\\n\\n    def pitch(self, angle):\\n        q = transformations.quaternion_about_axis(angle, [1, 0, 0])\\n        q = transformations.quaternion_multiply(self.rotation, q)\\n        q = q / np.linalg.norm(q)\\n        self.rotation = q\\n        self.dirty.add('rotation')\\n\\n    def roll(self, angle):\\n        q = transformations.quaternion_about_axis(angle, [0, 0, 1])\\n        q = transformations.quaternion_multiply(self.rotation, q)\\n        q = q / np.linalg.norm(q)\\n        self.rotation = q\\n        self.dirty.add('rotation')\\n\\n    def get_right(self):\\n        return transformations.rotate_vector(\\n            self.rotation, np.array((1, 0, 0), float))\\n        #x = transformations.quaternion_multiply(\\n        #    self.rotation, np.array((1.0, 0, 0, 0)))\\n        #x = x / np.linalg.norm(x)\\n        #return x[:3]\\n\\n    def get_up(self):\\n        return transformations.rotate_vector(\\n            self.rotation, np.array((0, 1, 0), float))\\n        #x = transformations.quaternion_multiply(\\n        #    self.rotation, np.array((0.0, 1.0, 0, 0)))\\n        #x = x / np.linalg.norm(x)\\n        #return x[:3]\\n\\n    def get_forward(self):\\n        return transformations.rotate_vector(\\n            self.rotation, np.array((0, 0, -1), float))\\n        #x = transformations.quaternion_multiply(\\n        #    self.rotation, np.array((0.0, 0.0, -1.0, 0)))\\n        #x = x / np.linalg.norm(x)\\n        #return x[:3]\\n\\n    def get_ahead_position(self, distance):\\n        return self.position + self.get_forward() * distance\\n\\n    def get_forward_ray(self):\\n        return Ray(self.position, self.get_forward())\\n\\n    def set_position(self, position):\\n        self.position = np.asarray(position, float)\\n        self.dirty.add('position')\\n\\n    def set_rotation(self, rotation):\\n        self.rotation = np.asarray(rotation, float)\\n        self.dirty.add('rotation')\\n\\n    def look_at(self, target):\\n        target = np.asarray(target, float)\\n        forward = normalize(self.position - target)\\n        global_up = np.array([0, 1, 0], float)\\n        right = np.cross(global_up, forward)\\n        up = np.cross(forward, right)\\n\\n        rotation_matrix = transformations.identity_matrix()\\n        rotation_matrix[0, :3] = right\\n        rotation_matrix[1, :3] = up\\n        rotation_matrix[2, :3] = forward\\n\\n        self.set_rotation(\\n            transformations.quaternion_from_matrix(\\n                transformations.inverse_matrix(rotation_matrix)))\\n\\n    def approach(self, target, closeness=50):\\n        p = target.position.copy()\\n        p[0] += target.size[0] / 2\\n        p[1] += target.size[1] / 2\\n        center = p.copy()\\n        p[2] += closeness\\n        self.set_position(p)\\n        self.look_at(center)\\n\\n    def update(self):\\n        if self.dirty:\\n            position_matrix = transformations.translation_matrix(self.position)\\n            rotation_matrix = transformations.quaternion_matrix(self.rotation)\\n            camera_matrix = transformations.concatenate_matrices(\\n                position_matrix, rotation_matrix\\n            )\\n            self.view_matrix = transformations.inverse_matrix(camera_matrix) \\\\\\n                    .astype(float).flatten('F')\\n            self.dirty.clear()\\n            self.changed.emit()\\n\\n    def get_view_matrix(self):\\n        self.update()\\n        return self.view_matrix\\n\", \"name\": \"Camera\"}", "created_at": null, "updated_at": 1751906432.7386982}