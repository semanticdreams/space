{"id": "336", "type": "class", "data": "{\"code_str\": \"class Floaties:\\n    def __init__(self):\\n        setattr(world, 'floaties', self)\\n\\n        self.floaties = {}\\n        self.changed = z.Signal()\\n\\n        self.layout = z.Layout(measurer=self.measurer, layouter=self.layouter,\\n                                       #uses_child_measures=False,\\n                                       name='floaties')\\n\\n        self.spacing = 1\\n        self.min_tile_size = np.array((5, 60, 0))\\n        self.row_heights = {}\\n        self.col_widths = {}\\n        self.tiles = {}\\n        self.next_free_tile = [0, 0]\\n        self.distance = 200\\n\\n        self.to_hud = False\\n\\n        self.on_projection_changed()\\n        world.projection.changed.connect(self.on_projection_changed)\\n        world.camera.camera.changed.connect(self.on_camera_changed)\\n\\n        self.layout_root = z.LayoutRoot()\\n        self.layout.set_root(self.layout_root)\\n        self.layout.mark_measure_dirty()\\n\\n    def on_projection_changed(self):\\n        self.alignment = z.ViewportAlignment(self.distance, projection=world.projection)\\n        self.layout.mark_measure_dirty()\\n\\n    def on_camera_changed(self):\\n        self.layout.mark_layout_dirty()\\n\\n    def update(self):\\n        self.layout_root.update()\\n\\n    def measurer(self):\\n        #self.row_heights.clear()\\n        #self.col_widths.clear()\\n        for floatie in self.floaties.values():\\n            floatie.layout.measurer()\\n\\n    def layouter(self):\\n        if not self.floaties:\\n            return\\n        width = max(x.measure[0]  for x in self.layout.children)\\n        offset = np.array((0, 0, 0), float)\\n        y_cursor_left = y_cursor_right = self.alignment.height/2 - 7 - self.spacing\\n        offset[2] -= self.distance\\n        for i, floatie in enumerate(self.floaties.values()):\\n            offset[2] += i * 0.01\\n            floatie.layout.size = np.array((width, floatie.layout.measure[1], floatie.layout.measure[2]), float)\\n            if floatie.side == 'left':\\n                offset[0] = -self.alignment.width/2\\n                y_cursor_left -= self.spacing + floatie.layout.size[1]\\n                offset[1] = y_cursor_left\\n            else:\\n                offset[0] = self.alignment.width/2 - width\\n                y_cursor_right -= self.spacing + floatie.layout.size[1]\\n                offset[1] = y_cursor_right\\n            floatie.layout.rotation = world.camera.camera.rotation\\n            floatie.layout.position = transformations.rotate_vector(floatie.layout.rotation, offset) + world.camera.camera.position\\n            try:\\n                floatie.layout.layouter()\\n            except Exception as e:\\n                raise\\n                #import traceback; print('err', traceback.format_exc())\\n                #world.next_tick(lambda e=e: (world.floaties.drop_obj(floatie.obj),\\n                #                             world.error_views.add(e)))\\n\\n    def on_obj_moved(self, drag):\\n        for obj in world.apps['ObjectSelector'].selected:\\n            if obj.handle == drag.spatiolator.handle:\\n                for o in world.apps['ObjectSelector'].selected:\\n                    if o != obj:\\n                        o.set_position(\\n                            o.get_position() \\\\\\n                            + (obj.get_position() - (drag.offset + drag.start_pos)))\\n        self.changed.emit()\\n\\n    def add(self, o=None, code_entity=None, side='left'):\\n        if o is None:\\n            o = eval(code_entity.code_str)\\n        floatie = z.Floatie(o, tuple(self.next_free_tile), code_entity, side=side)\\n        if self.to_hud:\\n            world.apps['Hud'].worktop.add(floatie)\\n            #self.floaties[floatie.obj] = floatie\\n        else:\\n            self.next_free_tile[0] += 1\\n            self.tiles[floatie.tile] = floatie\\n            self.floaties[floatie.obj] = floatie\\n            self.layout.add_child(floatie.layout)\\n            world.apps['ObjectSelector'].add_selectables([floatie])\\n            world.apps['Spatiolation'].add_spatiolatable(\\n                floatie,\\n                on_moved=self.on_obj_moved\\n            )\\n            self.layout.mark_measure_dirty()\\n\\n        self.changed.emit()\\n\\n        if not floatie.focus.has_current_descendant():\\n            world.focus.set_focus(floatie.focus)\\n\\n        return floatie\\n\\n    def drop_obj(self, o, emit_changed=True):\\n        floatie = self.floaties.pop(o)\\n        self.tiles.pop(floatie.tile)\\n        if floatie.tile[0] < self.next_free_tile[0]:\\n            self.next_free_tile[0] = floatie.tile[0]\\n        self.layout.remove_child(floatie.layout)\\n        world.apps['ObjectSelector'].remove_selectables([floatie])\\n        world.apps['Spatiolation'].remove_spatiolatable(floatie)\\n        floatie.drop()\\n        o.drop()\\n        self.layout.mark_measure_dirty()\\n        if emit_changed:\\n            self.changed.emit()\\n\\n    def drop_all(self):\\n        while self.floaties:\\n            o, floatie = next(iter(self.floaties.items()))\\n            self.drop_obj(o, emit_changed=False)\\n        self.changed.emit()\\n\\n    def drop(self):\\n        self.drop_all()\\n        self.layout.drop()\\n\", \"name\": \"Floaties\"}", "created_at": null, "updated_at": 1754736945.4815054}