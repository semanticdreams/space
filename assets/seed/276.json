{"id": "276", "type": "class", "data": "{\"code_str\": \"from collections import defaultdict\\n\\n\\nclass DynamicGraph:\\n    def __init__(self, focus_parent=None):\\n        self.focus = (focus_parent or world.focus).add_child(self)\\n        self.entity = world.apps['Entities'].get_entity(\\n            '4c04f274-c318-4e01-935f-a00a2d57c65f'\\n        )\\n\\n        self.profiler = z.Profiler('dynamic-graph')\\n\\n        self.points = {}\\n        self.labels = {}\\n        self.lines = {}\\n\\n        self.node_view_objs = {}\\n\\n        self.lod = {}\\n\\n        self.selected_nodes = []\\n        self.selected_nodes_changed = z.Signal()\\n\\n        self.force_layout = z.ForceLayout(\\n            spring_rest_length=self.entity.force_layout_params.get('spring_rest_length', 50),\\n            repulsive_force_constant=self.entity.force_layout_params.get('repulsive_force_constant', 6250),\\n            spring_constant=self.entity.force_layout_params.get('spring_constant', 1),\\n            max_displacement_squared=self.entity.force_layout_params.get('max_displacement_squared', 100),\\n            center_force=self.entity.force_layout_params.get('center_force', 0.0001),\\n            stabilized_max_displacement=self.entity.force_layout_params.get('stabilized_max_displacement', 0.02),\\n            stabilized_avg_displacement=self.entity.force_layout_params.get('stabilized_avg_displacement', 0.01),\\n        )\\n        self.force_layout.stabilized.connect(self.on_force_layout_stabilized)\\n\\n        self.force_layout_view = z.ForceLayoutView(self.force_layout)\\n        self.force_layout_view.params_changed.connect(\\n            self.save_force_layout_params)\\n\\n        self.column = z.Flex([\\n            z.FlexChild(self.force_layout_view.layout),\\n        ], axis='y', xalign='largest')\\n\\n        self.layout = self.column.layout\\n\\n        world.camera.debounced_camera_position.changed.connect(self.debounced_camera_position_changed)\\n\\n        world.apps['ObjectSelector'].changed.connect(self.on_selection_changed)\\n\\n        world.updated.connect(self.update)\\n\\n        self.add_node(z.StartNode(), pinned=True)\\n\\n        world.vim.add_mode(z.DynamicGraphVimMode())\\n        world.vim.modes['leader'].add_action_group(z.VimActionGroup('dynamic-graph', [\\n            z.VimAction('dynamic-graph', self.set_current_mode_graph, sdl2.SDLK_g),\\n        ]))\\n\\n    def set_current_mode_graph(self):\\n        world.vim.set_current_mode('dynamic-graph')\\n\\n    def update_labels(self, nodes=None):\\n        if nodes is None:\\n            nodes = self.points.keys()\\n        for node in nodes:\\n            point = self.points[node]\\n            distance = np.linalg.norm(\\n                point.layout.position - world.camera.debounced_camera_position.position)\\n            current_lod = self.lod.get(node)\\n            if distance < 250:\\n                target_lod = 0\\n            elif distance < 500:\\n                target_lod = 1\\n            elif distance < 800:\\n                target_lod = 2\\n            else:\\n                target_lod = 3\\n            if current_lod != target_lod:\\n                if target_lod < 3:\\n                    if target_lod == 0:\\n                        text_length, line_length, text_scale = 120, 30, 3\\n                    elif target_lod == 1:\\n                        text_length, line_length, text_scale = 60, 20, 5\\n                    else:\\n                        text_length, line_length, text_scale = 20, None, 8\\n                    text = util.truncate_string_with_ellipsis(node.label, text_length)\\n                    if line_length:\\n                        text = util.wrap_text2(text, line_length)\\n                    if current_lod is None or current_lod >= 3:\\n                        span = z.Text(text, style=z.TextStyle(\\n                            scale=text_scale, color=(0.6, 0.6, 0.6, 1)))\\n                        self.labels[node] = span\\n                    else:\\n                        span = self.labels[node]\\n                        span.set_text(text)\\n                        span.style.scale = text_scale\\n                    span.layout.measurer()\\n                    offset = np.array((\\n                        -span.layout.measure[0]/2 + point.layout.size[0]/2,\\n                         -span.layout.measure[1],\\n                         0.05\\n                    ))\\n                    span.layout.position = point.layout.position + offset\\n                    span.layout.rotation = point.layout.rotation.copy()\\n                    span.layout.layouter()\\n                else:\\n                    if current_lod is not None:\\n                        self.labels.pop(node).drop()\\n                self.lod[node] = target_lod\\n\\n    def debounced_camera_position_changed(self):\\n        self.update_labels()\\n\\n    def on_selection_changed(self):\\n        self.selected_nodes = [node for node, point in self.points.items()\\n                               if point in world.apps['ObjectSelector'].selected]\\n        self.selected_nodes_changed.emit()\\n\\n        self.update_node_views()\\n\\n    def update_node_views(self):\\n        for node, view in list(self.node_view_objs.items()):\\n            if node not in self.selected_nodes:\\n                world.floaties.drop_obj(view)\\n                self.node_view_objs.pop(node)\\n        for node in self.selected_nodes:\\n            if node.view and node not in self.node_view_objs:\\n                obj = node.view(node)\\n                self.node_view_objs[node] = obj\\n                world.floaties.add(obj, side='right')\\n\\n    def pin_node_view(self, obj):\\n        # removing node view obj from self.node_view_objs will\\n        # prevent its removal in update\\n        self.node_view_objs = {k: v for k, v in self.node_view_objs.items()\\n                               if v != obj}\\n\\n    def add_node(self, node, update_force_layout=True, pinned=False):\\n        node.mount(self)\\n        point = z.Point(\\n            color=node.color, sub_color=node.sub_color, size=8, pinned=pinned,\\n            on_click=lambda f, i, d, node=node: self.node_clicked(node),\\n            on_double_click=lambda f, i, d, node=node: self.node_double_clicked(node),\\n        )\\n        point.layout.measurer()\\n        point.layout.size = point.layout.measure\\n        point.layout.position = np.array(\\n            self.entity.positions.get(node.key, (0, 0, 0)), float)\\n        point.layouter()\\n        self.points[node] = point\\n        world.apps['Spatiolation'].add_spatiolatable(point.layout, on_moved=lambda drag: self.on_obj_moved())\\n        world.apps['ObjectSelector'].add_selectables([point])\\n        if update_force_layout:\\n            self.update_force_layout()\\n        self.update_labels([node])\\n\\n    def node_changed(self, node):\\n        if span := self.labels.get(node):\\n            self.update_labels([node])\\n        if point := self.points.get(node):\\n            point.set_sub_color(node.sub_color)\\n\\n    def remove_node(self, node, update_force_layout=True, clear_broken_edges=True):\\n        node.unmount()\\n        node.drop()\\n        point = self.points.pop(node)\\n        world.apps['Spatiolation'].remove_spatiolatable(point.layout)\\n        world.apps['ObjectSelector'].remove_selectables([point])\\n        point.drop()\\n        if span := self.labels.pop(node, None):\\n            span.drop()\\n        if clear_broken_edges:\\n            self.clear_broken_edges()\\n        if update_force_layout:\\n            self.update_force_layout()\\n\\n    def clear_broken_edges(self):\\n        for (source, target), line in list(self.lines.items()):\\n            if source not in self.points or target not in self.points:\\n                line.drop()\\n                del self.lines[(source, target)]\\n\\n    def add_edge(self, edge, update_force_layout=True):\\n        if edge.source not in self.points:\\n            self.add_node(edge.source, update_force_layout=False)\\n        if edge.target not in self.points:\\n            self.add_node(edge.target, update_force_layout=False)\\n        source_layout = self.points[edge.source].layout\\n        target_layout = self.points[edge.target].layout\\n        if not np.any(target_layout.position):\\n            target_layout.position = source_layout.position * 1.2\\n        line = z.TriangleLine(\\n            source_layout.position + source_layout.size/2,\\n            target_layout.position + target_layout.size/2,\\n            color=edge.color,\\n        )\\n        line.update()\\n        self.lines[(edge.source, edge.target)] = line\\n        if update_force_layout:\\n            self.update_force_layout()\\n\\n    def node_clicked(self, node):\\n        if point := self.points.get(node):\\n            world.apps['ObjectSelector'].set_selected([point])\\n\\n    def node_double_clicked(self, node):\\n        for edge in node.get_edges():\\n            self.add_edge(edge)\\n\\n    def update(self, delta):\\n        self.profiler.enable()\\n        self.force_layout.update()\\n        if self.force_layout.active \\\\\\n           and time.time() - self.last_force_layout_position_update > 0.3:\\n            self.update_force_layout_positions()\\n        positions_changed = False\\n        for node, point in self.points.items():\\n            if point.layout.layout_dirty:\\n                point.layout.layouter()\\n                point.layout.layout_dirty = False\\n                if span := self.labels.get(node):\\n                    span.layout.position = point.layout.position + np.array((-span.layout.measure[0]/2 + point.layout.size[0]/2, -span.layout.measure[1], 0.05))\\n                    span.layout.layouter()\\n                positions_changed = True\\n        if positions_changed:\\n            for (source, target), line in self.lines.items():\\n                source_layout = self.points[source].layout\\n                target_layout = self.points[target].layout\\n                line.set_start_position(source_layout.position + source_layout.size/2)\\n                line.set_end_position(target_layout.position + target_layout.size/2)\\n                line.update()\\n        self.profiler.disable()\\n\\n    def update_force_layout(self):\\n        self.force_layout.clear()\\n        self.indices = {}\\n        for i, point in enumerate(self.points.values()):\\n            self.force_layout.add_node(point.layout.position)\\n            self.indices[point] = i\\n            if point.pinned:\\n                self.force_layout.pin_node(i, True)\\n        for source, target in self.lines.keys():\\n            self.force_layout.add_edge(\\n                self.indices[self.points[source]],\\n                self.indices[self.points[target]],\\n            )\\n        if self.points:\\n            self.last_force_layout_position_update = time.time()\\n            self.force_layout.start()\\n\\n    def update_force_layout_positions(self):\\n        self.last_force_layout_position_update = time.time()\\n        for point, i in self.indices.items():\\n            point.layout.set_position(np.array((*self.force_layout.positions[i], 0)))\\n        #self.shift_positions_to_center([0, 500, 0])\\n\\n    def save_force_layout_params(self):\\n        self.force_layout.update_params()\\n        self.entity.force_layout_params = {\\n            'repulsive_force_constant': self.force_layout.repulsive_force_constant,\\n            'spring_rest_length': self.force_layout.spring_rest_length,\\n            'spring_constant': self.force_layout.spring_constant,\\n            'max_displacement_squared': self.force_layout.max_displacement_squared,\\n            'center_force': self.force_layout.center_force,\\n            'stabilized_max_displacement': self.force_layout.stabilized_max_displacement,\\n            'stabilized_avg_displacement': self.force_layout.stabilized_avg_displacement,\\n        }\\n        self.entity.save()\\n\\n    def save_positions(self):\\n        for node, point in self.points.items():\\n            self.entity.positions[node.key] = point.layout.position.tolist()\\n        self.entity.save()\\n\\n    def shift_positions(self, offset):\\n        for point in self.points.values():\\n            point.layout.position += np.asarray(offset, float)\\n            self.force_layout.set_position(self.indices[point], point.layout.position)\\n        self.save_positions()\\n\\n    def shift_positions_to_center(self, center):\\n        current_center = np.sum(np.array(\\n            [x.layout.position for x in self.points.values()]), axis=0) / len(self.points)\\n        self.shift_positions(np.asarray(center) - current_center)\\n\\n    def on_obj_moved(self):\\n        for point in self.points.values():\\n            i = self.indices[point]\\n            self.force_layout.set_position(i, point.layout.position)\\n        self.save_positions()\\n\\n    def on_force_layout_stabilized(self):\\n        self.update_force_layout_positions()\\n        self.save_positions()\\n\\n    def drop_points(self):\\n        world.apps['ObjectSelector'].remove_selectables(self.points.values())\\n        for node, point in self.points.items():\\n            node.drop() # maybe use drop_nodes but need to move nodes to own list\\n            world.apps['Spatiolation'].remove_spatiolatable(point.layout)\\n            point.drop()\\n        self.points.clear()\\n\\n    def drop_labels(self):\\n        for node, span in self.labels.items():\\n            span.drop()\\n        self.labels.clear()\\n\\n    def drop_lines(self):\\n        for line in self.lines.values():\\n            line.drop()\\n        self.lines.clear()\\n\\n    def drop(self):\\n        world.vim.modes['leader'].remove_action_group('dynamic-graph')\\n        world.vim.remove_mode('dynamic-graph')\\n        self.profiler.dump()\\n        self.profiler.svg()\\n        self.force_layout_view.params_changed.disconnect(\\n            self.save_force_layout_params)\\n        self.column.drop()\\n        self.force_layout_view.drop()\\n        world.camera.debounced_camera_position.changed.disconnect(self.debounced_camera_position_changed)\\n        world.updated.disconnect(self.update)\\n        self.force_layout.drop()\\n        self.drop_points()\\n        self.drop_labels()\\n        self.drop_lines()\\n\", \"name\": \"DynamicGraph\"}", "created_at": null, "updated_at": 1754736945.4576573}