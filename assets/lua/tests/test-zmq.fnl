(local tests [])
(local zmq (require :zmq))
(local fs (require :fs))

(fn msg->string [msg]
  ((. msg :to-string) msg))

(fn zmq-version []
  (local version (zmq.version))
  (assert (and version.major version.minor version.patch))
  true)

(fn req-rep-roundtrip []
  (local socket-types (. zmq :socket-types))
  (local ctx (zmq.Context 1))
  (local rep (ctx:socket socket-types.REP))
  (local req (ctx:socket socket-types.REQ))
  (rep:bind "inproc://req-rep")
  (req:connect "inproc://req-rep")
  (req:send "ping")
  (local msg (rep:recv))
  (assert (= (msg->string msg) "ping"))
  (rep:send "pong")
  (local reply (req:recv))
  (assert (= (msg->string reply) "pong"))
  (rep:close)
  (req:close)
  (ctx:close)
  true)

(fn multipart-send-recv []
  (local socket-types (. zmq :socket-types))
  (local ctx (zmq.Context 1))
  (local sender (ctx:socket socket-types.PAIR))
  (local receiver (ctx:socket socket-types.PAIR))
  (sender:bind "inproc://multipart")
  (receiver:connect "inproc://multipart")
  (sender:send ["alpha" "beta" "gamma"])
  (local parts (receiver:recv-multipart))
  (assert (= (length parts) 3))
  (assert (= (msg->string (. parts 1)) "alpha"))
  (assert (= (msg->string (. parts 2)) "beta"))
  (assert (= (msg->string (. parts 3)) "gamma"))
  (sender:close)
  (receiver:close)
  (ctx:close)
  true)

(fn nonblocking-and-poll []
  (local socket-types (. zmq :socket-types))
  (local recv-flags (. zmq :recv-flags))
  (local poll-events (. zmq :poll-events))
  (local ctx (zmq.Context 1))
  (local sender (ctx:socket socket-types.PAIR))
  (local receiver (ctx:socket socket-types.PAIR))
  (sender:bind "inproc://poll")
  (receiver:connect "inproc://poll")
  (assert (= (receiver:recv recv-flags.DONTWAIT) nil))
  (sender:send "ready")
  (local polled (zmq.poll [{:socket receiver :events poll-events.IN}] 10))
  (local revents (. (. polled 1) "revents"))
  (assert (> revents 0))
  (local msg (receiver:recv))
  (assert (= (msg->string msg) "ready"))
  (sender:close)
  (receiver:close)
  (ctx:close)
  true)

(fn socket-options []
  (local socket-types (. zmq :socket-types))
  (local ctx (zmq.Context 1))
  (local dealer (ctx:socket socket-types.DEALER))
  (dealer:set-option-int "linger" 0)
  (assert (= (dealer:get-option-int "linger") 0))
  (dealer:set-option-string "identity" "unit-test")
  (assert (= (dealer:get-option-string "identity") "unit-test"))
  (dealer:close)
  (ctx:close)
  true)

(fn ipc-req-rep-roundtrip []
  (local socket-types (. zmq :socket-types))
  (local ctx (zmq.Context 1))
  (local rep (ctx:socket socket-types.REP))
  (local req (ctx:socket socket-types.REQ))
  (local suffix (.. (os.time) "-" (math.floor (* (os.clock) 1000000))))
  (local path (fs.join-path "/tmp" (.. "space-zmq-" suffix ".sock")))
  (local endpoint (.. "ipc://" path))
  (when (fs.exists path)
    (fs.remove path))
  (local (ok err) (pcall (fn [] (rep:bind endpoint))))
  (when (not ok)
    (when (or (string.find err "Operation not permitted" 1 true)
              (string.find err "Permission denied" 1 true))
      (print "Skipping ZMQ ipc req/rep test: ipc bind not permitted")
      (rep:close)
      (req:close)
      (ctx:close)
      (when (fs.exists path)
        (fs.remove path))
      (lua "return true"))
    (error err))
  (req:connect endpoint)
  (req:send "hello")
  (local msg (rep:recv))
  (assert (= (msg->string msg) "hello"))
  (rep:send "world")
  (local reply (req:recv))
  (assert (= (msg->string reply) "world"))
  (rep:close)
  (req:close)
  (ctx:close)
  (when (fs.exists path)
    (fs.remove path))
  true)

(table.insert tests {:name "ZMQ version reports major/minor/patch" :fn zmq-version})
(table.insert tests {:name "ZMQ req/rep roundtrip" :fn req-rep-roundtrip})
(table.insert tests {:name "ZMQ multipart send/recv" :fn multipart-send-recv})
(table.insert tests {:name "ZMQ nonblocking recv and poll" :fn nonblocking-and-poll})
(table.insert tests {:name "ZMQ socket options roundtrip" :fn socket-options})
(table.insert tests {:name "ZMQ ipc req/rep roundtrip" :fn ipc-req-rep-roundtrip})

(local main
  (fn []
    (local runner (require :tests/runner))
    (runner.run-tests {:name "zmq"
                       :tests tests})))

{:name "zmq"
 :tests tests
 :main main}
